/**
 * <copyright>
 * Copyright (c) 1995, 2015 Technische Universit√§t Berlin. All rights reserved. This program and the accompanying
 * materials are made available under the terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 * 
 * Copyright (c) 2025, Janusch Rentenatus. This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v2.0 which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v20.html
 * </copyright>
 */
package agg.xt_basis;

import agg.attribute.AttrContext;
import agg.attribute.AttrException;
import agg.attribute.AttrInstance;
import agg.attribute.AttrManager;
import agg.attribute.AttrMapping;
import agg.attribute.handler.AttrHandlerException;
import agg.attribute.handler.HandlerExpr;
import agg.attribute.impl.AttrTupleManager;
import agg.attribute.impl.CondMember;
import agg.attribute.impl.CondTuple;
import agg.attribute.impl.ContextView;
import agg.attribute.impl.DeclMember;
import agg.attribute.impl.ValueMember;
import agg.attribute.impl.ValueTuple;
import agg.attribute.impl.VarMember;
import agg.attribute.impl.VarTuple;
import agg.util.Change;
import agg.util.ExtObservable;
import agg.util.Pair;
import agg.util.XMLHelper;
import agg.xt_basis.csp.CompletionPropertyBits;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Dictionary;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * Implementation of a graph morphism. Note: This implementation is guaranteed to keep morphism properties when objects
 * are deleted/created/modified in the original or image graphs.
 */
// Class OrdinaryMorphism is capable of passing the following change
// informations as an argument to its observers' <code>update()</code> methods:
// Morph_Change_MappingAdded, Morph_Change_MappingRemoved.
// Additionally, the information <code>Change_ObservableGone</code>
// may be generated by its base class <code>ExtObservable</code>.
// If, however, the value of the change information is given as
// <code>null</code>, the observer is recommended to perform a full
// rescan of the morphism.
public class OrdinaryMorphism extends ExtObservable implements Morphism // , Observer
{

    protected String itsName;
    protected String comment = "";

    protected MorphCompletionStrategy itsCompleter;
    protected boolean itsTouchedFlag = true;
    protected boolean itsInteractiveFlag = true;

    protected Map<AttrInstance, AttrMapping> itsAttrMappings;
    protected AttrContext itsAttrContext;
    protected AttrManager itsAttrManager;

    protected Graph itsOrig;
    protected Graph itsImag;

    /**
     * Use this constant as a parameter in my constructors or in the <code>initialize()</code> method to indicate that
     * the attribute context in question should not be altered.
     */
    protected static final AttrContext cKeepContext = null;

    final protected List<GraphObject> itsDomObjects = new ArrayList<>();
    final protected List<GraphObject> itsCodomObjects = new ArrayList<>();

    protected OrdinaryMorphism itsCoMorph;

    protected boolean enabled = true;
    boolean mappingChanged;
    protected boolean changed;
    protected boolean typeObjectsMapChanged;
    protected boolean partialMorphCompletion;

    protected boolean shifted;

    protected String errorMsg;
//	protected List<String> errors;

    protected OrdinaryMorphism() {
        this(new Graph(), new Graph(), cKeepContext);
    }

    /**
     * @param ac my attribute context.
     */
    protected OrdinaryMorphism(final AttrContext ac) {
        this(new Graph(), new Graph(), ac);
    }

    /**
     * @param orig my original graph.
     * @param img my image graph.
     */
    public OrdinaryMorphism(final Graph orig, final Graph img) {
        this(orig, img, cKeepContext);
    }

    /**
     * @param orig my original graph.
     * @param img my image graph.
     * @param ac my attribute context.
     */
    public OrdinaryMorphism(final Graph orig, final Graph img, final AttrContext ac) {
        this.itsName = "OrdinaryMorphism";

        this.itsOrig = orig;
//		this.itsOrig.setKind(GraphKind.SOURCE);
        this.itsOrig.addUsingMorph(this);

        this.itsImag = img;
//		this.itsImag.setKind(GraphKind.TARGET);
        this.itsImag.addUsingMorph(this);

        this.itsAttrContext = ac;
        this.itsAttrMappings = new Hashtable<AttrInstance, AttrMapping>(20);
        this.itsAttrManager = AttrTupleManager.getDefaultManager();

        setCompletionStrategy(CompletionStrategySelector.getDefault());
        this.itsTouchedFlag = true;
        this.itsInteractiveFlag = true;

        this.errorMsg = "";
//		this.errors = new List<String>(2, 2);
    }

    /**
     * Remove all graph object mappings and all relations to its source and target graphs.
     */
    public void dispose() {
        if (this.itsCompleter != null) {
            this.itsCompleter.dispose();
        }

        removeAllMappings();

        this.itsOrig.removeUsingMorph(this);
        this.itsImag.removeUsingMorph(this);

        if (this.itsCoMorph != null) {
            this.itsCoMorph.dispose();
            this.itsCoMorph = null;
        }
        this.clearErrorMsg();

        super.dispose();
    }

    /**
     * Remove all graph object mappings and all relations to its source and target graphs. Dispose its source graph if
     * disposableSource is TRUE, dispose its target graph if disposableTarget is TRUE.
     */
    public void dispose(boolean disposableSource, boolean disposableTarget) {
        if (this.itsCompleter != null) {
            this.itsCompleter.dispose();
        }

        removeAllMappings();

        this.itsOrig.removeUsingMorph(this);
        this.itsImag.removeUsingMorph(this);

        if (this.itsCoMorph != null) {
            this.itsCoMorph.dispose();
            this.itsCoMorph = null;
        }
        this.clearErrorMsg();

        super.dispose();

        if (disposableSource) {
            this.itsOrig.dispose();
            this.itsOrig = null;
        }
        if (disposableTarget) {
            this.itsImag.dispose();
            this.itsImag = null;
        }
    }

    public boolean isInjectiveSet() {
        return this.getCompletionStrategy().getProperties().get(CompletionPropertyBits.INJECTIVE);
    }

    public boolean isDanglingSet() {
        return this.getCompletionStrategy().getProperties().get(CompletionPropertyBits.DANGLING);
    }

    public boolean isIdentificationSet() {
        return this.getCompletionStrategy().getProperties().get(CompletionPropertyBits.IDENTIFICATION);
    }

    public boolean isGluingConditionSet() {
        return this.getCompletionStrategy().getProperties().get(CompletionPropertyBits.DANGLING)
                && this.getCompletionStrategy().getProperties().get(CompletionPropertyBits.IDENTIFICATION);
    }

    public boolean isNotificationRequired() {
        return (this.countObservers() > 0);
    }

    public void setTarget(Graph g) {
        this.itsImag = g;
    }

    public void setSource(Graph g) {
        this.itsOrig = g;
    }

    public boolean isTypeObjectsMapChanged() {
        return this.typeObjectsMapChanged;
    }

    public void setTypeObjectsMapChanged(boolean b) {
        this.typeObjectsMapChanged = b;
    }

    public boolean hasPartialMorphismCompletion() {
        return this.partialMorphCompletion;
    }

    public void setPartialMorphismCompletion(boolean b) {
        this.partialMorphCompletion = b;
    }

    /**
     * Enable or disable this morphism to make it usable during transformation.
     */
    public void setEnabled(boolean enable) {
        this.enabled = enable;
    }

    /**
     * Returns TRUE if this morphism is active otherwise FALSE.
     */
    public boolean isEnabled() {
        return this.enabled;
    }

    /*
	 * This method is used for internal computations only. 
     */
    public boolean isShifted() {
        return this.shifted;
    }

    public void setErrorMsg(String msg) {
        this.errorMsg = msg;
    }

    /**
     * Return an error message if this morphism is failed, otherwise - empty message.
     */
    public String getErrorMsg() {
        return this.errorMsg;
    }

    /*
	public void addErrorMsg(String msg) {
		this.errorMsg = msg;
//		this.errors.add(this.errorMsg);
	}
     */
    public void clearErrorMsg() {
//		this.errors.clear();
        this.errorMsg = "";
        ((agg.attribute.impl.ContextView) this.getAttrContext()).getManager()
                .clearErrorMsg();
        ((agg.attribute.impl.ContextView) this.getAttrContext())
                .clearErrorMsg();
    }

    /**
     * Returns true, if the same source object refers the same target object, otherwise false. Precondition: this.source
     * == m.source, this.target == m.target
     */
    public final boolean isCommutative(Morphism m) {
        if (this.itsOrig.getTypeSet().isArcDirected()) {
            return isCommutative1(m);
        } else {
            return isCommutative2(m);
        }
    }

    private final boolean isCommutative1(Morphism m) {
        if (m == this) {
            return true;
        }

        if (m.getOriginal() == this.itsOrig) {
            final Iterator<Node> allOrigNodes = this.itsOrig.getNodesSet().iterator();
            while (allOrigNodes.hasNext()) {
                GraphObject anOrig = allOrigNodes.next();
                GraphObject anImage1 = this.getImage(anOrig);
                GraphObject anImage2 = m.getImage(anOrig);
                if (anImage1 == null) {
                    if (anImage2 != null) {
                        return false;
                    }
                } else if (anImage1 != anImage2) {
                    return false;
                }
            }
            final Iterator<Arc> allOrigArcs = this.itsOrig.getArcsSet().iterator();
            while (allOrigArcs.hasNext()) {
                GraphObject anOrig = allOrigArcs.next();
                GraphObject anImage1 = this.getImage(anOrig);
                GraphObject anImage2 = m.getImage(anOrig);
                if (anImage1 == null) {
                    if (anImage2 != null) {
                        return false;
                    }
                } else if (anImage1 != anImage2) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

    private final boolean isCommutativeORIG(Morphism m) {
        if (m == this) {
            return true;
        }

        if (m.getOriginal() == this.itsOrig) {
            final Iterator<Node> allOrigNodes = this.itsOrig.getNodesSet().iterator();
            while (allOrigNodes.hasNext()) {
                GraphObject anOrig = allOrigNodes.next();
                GraphObject anImage1 = this.getImage(anOrig);
                GraphObject anImage2 = m.getImage(anOrig);
                if (anImage1 == null) {
                    if (anImage2 == null) {
                        continue;
                    }
                    return false;
                } else if (anImage1 == anImage2) {
                    continue;
                }
                return false;
            }
            final Iterator<Arc> allOrigArcs = this.itsOrig.getArcsSet().iterator();
            while (allOrigArcs.hasNext()) {
                GraphObject anOrig = allOrigArcs.next();
                GraphObject anImage1 = this.getImage(anOrig);
                GraphObject anImage2 = m.getImage(anOrig);
                if (anImage1 == null) {
                    if (anImage2 == null) {
                        continue;
                    }
                    return false;
                } else if (anImage1 == anImage2) {
                    continue;
                }
                return false;
            }
            return true;
        }
        return false;
    }

    private final boolean isCommutative2(Morphism m) {
        if (m == this) {
            return true;
        }

        if (m.getOriginal() == this.itsOrig) {
            final Iterator<Arc> allOrigArcs = this.itsOrig.getArcsSet().iterator();
            while (allOrigArcs.hasNext()) {
                Arc anOrig = allOrigArcs.next();
                GraphObject anImage1 = this.getImage(anOrig);
                GraphObject anImage2 = m.getImage(anOrig);
                if (anImage1 == null) {
                    if (anImage2 != null) {
                        return false;
                    }
                } else if (anImage1 != anImage2) {
                    return false;
                }
            }
            // now check isolated nodes only
            final Iterator<Node> allOrigNodes = this.itsOrig.getNodesSet().iterator();
            while (allOrigNodes.hasNext()) {
                GraphObject anOrig = allOrigNodes.next();
                GraphObject anImage1 = this.getImage(anOrig);
                GraphObject anImage2 = m.getImage(anOrig);
                if (anImage1 == null) {
                    if (anImage2 != null) {
                        return false;
                    }
                } else if (anImage2 == null) {
                    return false;
                } else if (anImage1.getNumberOfInOutArcs() == 0
                        && anImage2.getNumberOfInOutArcs() == 0) {
                    if (anImage1 != anImage2) {
                        return false;
                    }
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Returns true, if the same source object of m1 and (this o m2) refers the same target object of this:
     * m2.getImage(this.getImage(obj)) == m1.getImage(obj). Otherwise returns false.
     *
     * Precondition: m1.source == this.source, m2.source == this.target, m1.target == m2.target
     */
    public final boolean isCommutative(Morphism m1, Morphism m2) {
        if (this.itsOrig.getTypeSet().isArcDirected()) {
            return isCommutative1(m1, m2);
        } else {
            return isCommutative2(m1, m2);
        }
    }

    @SuppressWarnings("unused")
    private final boolean isCommutativeORIG(Morphism m1, Morphism m2) {
        if (m1 == this) {
            return ((OrdinaryMorphism) m1).isCommutativeORIG(m2);
        }

        if (m1.getOriginal() == this.itsOrig
                && this.itsImag == m2.getOriginal()
                && m1.getImage() == m2.getImage()) {
            final Iterator<Node> allOrigNodes = this.itsOrig.getNodesSet().iterator();
            while (allOrigNodes.hasNext()) {
                GraphObject anOrig = allOrigNodes.next();
                GraphObject anImage = this.getImage(anOrig);
                GraphObject anImage1 = m1.getImage(anOrig);
                if (anImage == null) {
                    if (anImage1 == null) {
                        continue;
                    }
                    return false;
                } else if (m2.getImage(anImage) == anImage1) {
                    continue;
                }
                return false;
            }
            final Iterator<Arc> allOrigArcs = this.itsOrig.getArcsSet().iterator();
            while (allOrigArcs.hasNext()) {
                GraphObject anOrig = allOrigArcs.next();
                GraphObject anImage = this.getImage(anOrig);
                GraphObject anImage1 = m1.getImage(anOrig);
                if (anImage == null) {
                    if (anImage1 == null) {
                        continue;
                    }
                    return false;
                } else if (m2.getImage(anImage) == anImage1) {
                    continue;
                }
                return false;
            }
            return true;
        }
        return false;
    }

    private boolean isCommutative1(Morphism m1, Morphism m2) {
        if (m1 == this) {
            return ((OrdinaryMorphism) m1).isCommutative1(m2);
        }

        if (m1.getOriginal() == this.itsOrig
                && this.itsImag == m2.getOriginal()
                && m1.getImage() == m2.getImage()) {
            final Iterator<Node> allOrigNodes = this.itsOrig.getNodesSet().iterator();
            while (allOrigNodes.hasNext()) {
                GraphObject anOrig = allOrigNodes.next();
                GraphObject anImage = this.getImage(anOrig);
                GraphObject anImage1 = m1.getImage(anOrig);
                if (anImage == null) {
                    if (anImage1 == null) {
                        continue;
                    }
                    return false;
                } else if (m2.getImage(anImage) == anImage1) {
                    continue;
                }
                return false;
            }
            final Iterator<Arc> allOrigArcs = this.itsOrig.getArcsSet().iterator();
            while (allOrigArcs.hasNext()) {
                GraphObject anOrig = allOrigArcs.next();
                GraphObject anImage = this.getImage(anOrig);
                GraphObject anImage1 = m1.getImage(anOrig);
                if (anImage == null) {
                    if (anImage1 == null) {
                        continue;
                    }
                    return false;
                } else if (m2.getImage(anImage) == anImage1) {
                    continue;
                }
                return false;
            }
            return true;
        }
        return false;
    }

    private boolean isCommutative2(Morphism m1, Morphism m2) {
        if (m1 == this) {
            return ((OrdinaryMorphism) m1).isCommutative2(m2);
        }

        if (m1.getOriginal() == this.itsOrig
                && this.itsImag == m2.getOriginal()
                && m1.getImage() == m2.getImage()) {
            // check arcs first
            final Iterator<Arc> allOrigArcs = this.itsOrig.getArcsSet().iterator();
            while (allOrigArcs.hasNext()) {
                Arc anOrig = allOrigArcs.next();
                GraphObject anImage = this.getImage(anOrig);
                GraphObject anImage1 = m1.getImage(anOrig);
                GraphObject anImage2 = m2.getImage(anImage);
                if (anImage == null) {
                    if (anImage1 != null) {
                        return false;
                    }
                } else if (anImage2 != anImage1) {
                    return false;
                }
            }
            // now check isolated nodes only
            final Iterator<Node> allOrigNodes = this.itsOrig.getNodesSet().iterator();
            while (allOrigNodes.hasNext()) {
                GraphObject anOrig = allOrigNodes.next();
                GraphObject anImage = this.getImage(anOrig);
                GraphObject anImage1 = m1.getImage(anOrig);
                GraphObject anImage2 = m2.getImage(anImage);
                if (anImage == null) {
                    if (anImage1 != null) {
                        return false;
                    }
                } else if (anImage1 == null) {
                    return false;
                } else if (anImage.getNumberOfInOutArcs() == 0
                        && anImage1.getNumberOfInOutArcs() == 0) {
                    if (anImage1 != anImage2) {
                        return false;
                    }
                }
            }
            return true;
        }
        return false;
    }

    /**
     * *************************************************************************
     * Konstruiert aus dem Morphismus einen Match. * Der Morphismus muss zwischen der linken Regelseite * der
     * mitgegebenen Regel und dem aktuellen Arbeitsgraphen definiert sein.*
     * ************************************************************************
     */
    /**
     * Construct a Match of the specified Rule from this morphism . The source graph is the LHS of the rule. The mapping
     * of this morphism is used for the match mapping. Returns null when a BadMappingException occurred, otherwise true.
     */
    public Match makeMatch(Rule rule) {
        final Match m = (BaseFactory.theFactory()).createMatch(rule, this.itsImag);
        for (Iterator<GraphObject> elements = this.getDomain();
                elements.hasNext();) {
            final GraphObject grob = elements.next();
            try {
                m.addMapping(grob, this.getImage(grob));
            } catch (BadMappingException e) {
                this.errorMsg = e.getMessage();
//				if (this.errorMsg.length()>0)
//					this.errors.add(this.errorMsg);				
                m.dispose();
                return null;
            }
        }
        return m;
    }

    /**
     * Make a copy of the source graph, copy of the target graph, and the homomorphism on both graphs. The result shall
     * not poses far reaching references onto Rules, GraGras those kinds of objects.
     */
    public OrdinaryMorphism morphcopy() {
        synchronized (this) {
            boolean failed = false;

            final Hashtable<GraphObject, GraphObject> orig2copySource = new Hashtable<>();
            final Hashtable<GraphObject, GraphObject> orig2copyTarget = new Hashtable<>();

            Graph sourceCopy = this.itsOrig.copy(orig2copySource);
            Graph targetCopy = this.itsImag.copy(orig2copyTarget);

            if (sourceCopy == null && targetCopy == null) {
                return null;
            } else if (sourceCopy == null) {
                targetCopy = null;
                return null;
            } else if (targetCopy == null) {
                sourceCopy = null;
                return null;
            }

            // Mapping is still empty
            OrdinaryMorphism theCopy = (BaseFactory.theFactory())
                    .createMorphism(sourceCopy, targetCopy);
            Iterator<GraphObject> domainOrig = this.getDomain();
            while (!failed && domainOrig.hasNext()) {
                GraphObject x = domainOrig.next();

                if (x.isNode()) {
                    Node y = (Node) this.getImage(x);
                    if (y != null) {
                        Node xCopy = (Node) orig2copySource.get(x);
                        Node yCopy = (Node) orig2copyTarget.get(y);
                        try {
                            theCopy.addMapping(xCopy, yCopy);
                        } catch (BadMappingException ex) {
                        }
                    }
                }
            }
            domainOrig = this.getDomain();
            while (!failed && domainOrig.hasNext()) {
                GraphObject x = domainOrig.next();
                if (x.isArc()) {
                    Node vtx1 = (Node) (((Arc) x).getSource());
                    Node vtx2 = (Node) (((Arc) x).getTarget());
                    Node vtx1Copy = (Node) orig2copySource.get(vtx1);
                    Node vtx2Copy = (Node) orig2copySource.get(vtx2);
                    Arc y = (Arc) this.getImage(x);
                    Node vtx3Copy = null;
                    Node vtx4Copy = null;
                    if (y != null) {
                        Node vtx3 = (Node) y.getSource();
                        Node vtx4 = (Node) y.getTarget();

                        vtx3Copy = (Node) orig2copyTarget.get(vtx3);
                        vtx4Copy = (Node) orig2copyTarget.get(vtx4);
                    }
                    Arc q = null;
                    if (sourceCopy != null) {
                        Iterator<Arc> sourceCopyArcs = sourceCopy.getArcsSet().iterator();
                        while (sourceCopyArcs.hasNext()) {
                            Arc a = sourceCopyArcs.next();
                            if ((((Node) a.getSource()).equals(vtx1Copy))
                                    && (((Node) a.getTarget()).equals(vtx2Copy))) {
                                q = a;
                            }
                        }
                    }
                    Arc z = null;
                    if (vtx3Copy != null && vtx4Copy != null && targetCopy != null) {
                        Iterator<Arc> targetCopyArcs = targetCopy.getArcsSet().iterator();
                        while (targetCopyArcs.hasNext()) {
                            Arc a = targetCopyArcs.next();
                            if ((((Node) a.getSource()).equals(vtx3Copy))
                                    && (((Node) a.getTarget()).equals(vtx4Copy))) {
                                z = a;
                            }
                        }
                    }
                    if (q != null && z != null) {
                        try {
                            if (theCopy != null) {
                                theCopy.addMapping(q, z);
                            }
                        } catch (BadMappingException ex) {
                        }
                    } else {
                        failed = true;
                        if (theCopy != null) {
                            theCopy.dispose();
                        }
                        theCopy = null;
                        if (sourceCopy != null) {
                            sourceCopy.dispose();
                        }
                        sourceCopy = null;
                        if (targetCopy != null) {
                            targetCopy.dispose();
                        }
                        targetCopy = null;
                    }
                }

            }
            return (theCopy);
        }
    }

    /**
     * The current (this) morphism takes two morphisms with : <br>
     * theFirst.source == theSecond.source, <br>
     * this.source == theFirst.target, <br>
     * this.target == theSecond.target.<br>
     * Completes this morphism so that: <em>theFirst o this = theSecond</em> .
     */
    //
    // [Graph X]------------>[Graph Y]
    //     |      theFirst    /
    //     |                 /
    //     |                /
    //     |               /
    //     |              /
    //  the|Second       / this
    //     |            /
    //     |           /
    //     |          /
    //     |         /
    //     |        /
    //     |       /
    //    \|/    |/_
    //    [Graph Z]
    //
    // -----------------------------------------------------------
    public boolean makeDiagram(final OrdinaryMorphism theFirst,
            final OrdinaryMorphism theSecond) {
        if (!this.itsOrig.equals(theFirst.getImage())) {
            return (false);
        }
        if (!this.itsImag.equals(theSecond.getImage())) {
            return (false);
        }
        if (!theFirst.getOriginal().equals(theSecond.getOriginal())) {
            return (false);
        }

        // Untersuche Anwendungsvoraussetzungen: Graphen
        // (nur lesend, nicht schreibend)
        // Zusicherung hier: alle drei Morphismen leben auf den gleichen
        // Graphen.
        // ----------------------------------------------------------------------
        // Naechster Schritt: Untersuche Anwendungsvoraussetzungen.
        // Gemeinsame Elemente von theFirst und theSecond,
        // nur lesend, nicht schreibend
        // [Im folgenden wird pessimistisch angenommen, dass
        // die verwendeten Iterator nichtdeterministisch
        // (zufaellig) gefuellt worden seien, sodass man keine
        // Reihenfolgenkenntnisse effizient nutzbar machen kann.]
        Iterator<GraphObject> firstDom;
        Iterator<GraphObject> secondDom;

        firstDom = theFirst.getDomain();
        while (firstDom.hasNext()) {
            boolean result = false;
            GraphObject elem1 = firstDom.next();
            // System.out.println("--> elem1: "+elem1);
            secondDom = theSecond.getDomain();
            while (secondDom.hasNext()) {
                GraphObject elem2 = secondDom.next();
                // System.out.println("--> elem2: "+elem2);
                if (elem1.equals(elem2)) {
                    result = true;
                    break;
                }
            }
            if (result == false) {
                return (result);
                /**
                 * EXIT *
                 */
            }
        }

        secondDom = theSecond.getDomain();
        while (secondDom.hasNext()) {
            boolean result = false;
            GraphObject elem1 = secondDom.next();
            firstDom = theFirst.getDomain();
            while (firstDom.hasNext()) {
                GraphObject elem2 = firstDom.next();
                if (elem1.equals(elem2)) {
                    result = true;
                    break;
                }
            }
            if (result == false) {
                return (result);
            }
        }

        // Zusicherung hier: theFirst und theSecond haben den
        // selben Definitionsbereich.
        // ----------------------------------------------------------------
        // Naechster Schritt: Untersuche weitere Anwendungsvoraussetzungen.
        // Kompositionseigenschaften von ``this''
        // (nur lesend, nicht schreibend) **/
        Iterator<GraphObject> ownDom = this.getDomain();
        while (ownDom.hasNext()) {
            GraphObject y = ownDom.next();
            GraphObject z = this.getImage(y);
            Iterator<GraphObject> manyX = theFirst.getInverseImage(y);
            while (manyX.hasNext()) {
                GraphObject x = manyX.next();
//				if (theSecond.getImage(x) != z) 
                if (!(theSecond.getImage(x)).equals(z)) {
                    return (false);
                }

            }
        }

        // this.getAttrContext()).getAllowedMapping());
        // Zusicherung hier: Wo this definiert ist, gilt die Gleichung
        // this(theFirst(x))=theSecond(x)=z
        // --------------------------------
        // Letzter Schritt: Vervollstaendigung von this (schreibend!)
        firstDom = theFirst.getDomain();
        while (firstDom.hasNext()) {
            GraphObject x = firstDom.next();
            GraphObject y = theFirst.getImage(x);
            GraphObject z = theSecond.getImage(x);
            if (z != null) {
                if (!z.equals(this.getImage(y))) {
                    try {
                        if (y.isNode()) {
                            this.addMapping(y, z);
                        } else {
                            if (((Arc) z).getSource().equals(this.getImage(((Arc) y).getSource()))
                                    && ((Arc) z).getTarget().equals(this.getImage(((Arc) y).getTarget()))) {
                                this.addMapping(y, z);
                            }
                        }
                    } catch (BadMappingException ex) {
                        System.out.println(ex.getMessage());
                    }
                }
            }
        }
        return (true);
    }

    /**
     * <b>makeWeakDiagram</b>: fuer <em>DISAGG</em><br>
     * Der vorliegende Homomorphismus (this) nimmt zwei weitere (theFirst, theSecond) als Input und wird selbst so
     * vervollstaendigt, dass<br>
     * <em>theFirst o this <= theSecond</em>
     */
    //
    // [Graph X]-------------------->[Graph Y]
    //     \         theFirst          /
    //      \                         /
    //       \                       /
    //        \                     /
    //         \                   /
    //          \ theSecond       / this
    //           \               /
    //            \             /
    //             \           /
    //              \         /
    //               \       /
    //                \     /
    //                _\| |/_
    //               [Graph Z]
    //
    // -----------------------------------------------------------
    public boolean makeWeakDiagram(final OrdinaryMorphism theFirst,
            final OrdinaryMorphism theSecond) {

        /*
		 * System.out.println(">>> OrdinaryMorphism.makeWeakDiagram(1, 2)");
		 * 
		 * System.out.println("====="); System.out.println("FIRST : "+theFirst);
		 * System.out.println("SECOND: "+theSecond); System.out.println("THIS :
		 * "+this); if( !this.getOriginal().equals(theFirst.getImage()) )
		 * {return(false);} if( !this.getImage().equals(theSecond.getImage()) )
		 * {return(false);} if(
		 * !theFirst.getOriginal().equals(theSecond.getOriginal()) )
		 * {return(false);} // Untersuche Anwendungsvoraussetzungen: Graphen //
		 * (nur lesend, nicht schreibend) // Zusicherung hier: alle drei
		 * Morphismen leben auf den gleichen Graphen. //
		 * ---------------------------------------------------------------------- //
		 * Naechster Schritt: Untersuche Anwendungsvoraussetzungen. //
		 * Gemeinsame Elemente von theFirst und theSecond, // nur lesend, nicht
		 * schreibend // [Im folgenden wird pessimistisch angenommen, dass //
		 * die verwendeten Iteratoren nichtdeterministisch // (zufaellig)
		 * gefuellt worden seien, sodass man keine // Reihenfolgenkenntnisse
		 * effizient nutzbar machen kann.] /*
		 * if(!theFirst.getDomain().hasNext()) System.out.println("-->
		 * firstDom is EMPTY"); if(!theSecond.getDomain().hasNext())
		 * System.out.println("--> secondDom is EMPTY");
		 * if(!this.getDomain().hasNext()) System.out.println("-->
		 * thisDom is EMPTY");
         */
        if (!theFirst.getDomain().hasNext()
                && !theSecond.getDomain().hasNext()) {
            return this.nextCompletion();
        }

        // Zusicherung hier: theFirst und theSecond haben den
        // selben Definitionsbereich.
        // ----------------------------------------------------------------
        // Naechster Schritt: Untersuche weitere Anwendungsvoraussetzungen.
        // Kompositionseigenschaften von ``this''
        // (nur lesend, nicht schreibend) **/
        Iterator<GraphObject> ownDom = this.getDomain();
        while (ownDom.hasNext()) {
            GraphObject y = ownDom.next();
            // System.out.println("--> y: "+y);
            GraphObject z = this.getImage(y);
            // System.out.println("--> z: "+z);
            Iterator<GraphObject> manyX = theFirst.getInverseImage(y);
            while (manyX.hasNext()) {
                GraphObject x = manyX.next();
                // System.out.println("--> x: "+x);
                if (!(theSecond.getImage(x)).equals(z)) {
                    return (false);
                }
            }
        }

        Iterator<GraphObject> firstDom = theFirst.getDomain();
        // Zusicherung hier: Wo this definiert ist, gilt die Gleichung
        // this(theFirst(x))=theSecond(x)=z
        // --------------------------------
        // Letzter Schritt: Vervollstaendigung von this (schreibend!)
        firstDom = theFirst.getDomain();
        while (firstDom.hasNext()) {
            GraphObject x = firstDom.next();
            GraphObject y = theFirst.getImage(x);
            GraphObject z = theSecond.getImage(x);
            if (z != null) {
                if (!z.equals(this.getImage(y))) {
                    try {
                        this.addMapping(y, z);
                    } catch (BadMappingException ex) {
                    }
                }
            }
        }
        if (!theFirst.getDomain().hasNext()
                || !theSecond.getDomain().hasNext()) {
            return this.nextCompletion();
        }

        return (true);
    }

    /**
     * The current Homomorphismus (this) morphism takes two morphisms with : <br>
     * theFirst.source == theSecond.source, <br>
     * this.source == theFirst.target, <br>
     * this.target == theSecond.target.<br>
     * Completes this morphism so that: <em>theFirst o this = theSecond</em> .
     */
    //
    // [Graph X]------------------>[Graph Y]
    //	  \          theFirst         /
    //     \                         /
    //      \                       /
    //       \                     /
    //        \                   /
    //         \ theSecond       / this
    //          \               /
    //           \             /
    //            \           /
    //             \         /
    //              \       /
    //               \     /
    //               _\| |/_
    //              [Graph Z]
    //
    // -----------------------------------------------------------
    public boolean makeFullDiagram(final OrdinaryMorphism theFirst,
            final OrdinaryMorphism theSecond) {
        if (!this.itsOrig.equals(theFirst.getImage())) {
            return (false);
        }
        if (!this.itsImag.equals(theSecond.getImage())) {
            return (false);
        }
        if (!theFirst.getOriginal().equals(theSecond.getOriginal())) {
            return (false);
        }

        Iterator<GraphObject> firstDom;
        Iterator<GraphObject> secondDom;

        /* suche nach gemeinsammen Elementen in theFirst und theSecond */
        firstDom = theFirst.getOriginal().iteratorOfElems();
        while (firstDom.hasNext()) {
            boolean result = false;
            GraphObject elem1 = firstDom.next();
            secondDom = theSecond.getOriginal().iteratorOfElems();
            while (secondDom.hasNext()) {
                GraphObject elem2 = secondDom.next();
                if (elem1.equals(elem2)) {
                    result = true;
                    break;
                }
            }
            if (!result) {
                return result;
            }
        }

        secondDom = theSecond.getOriginal().iteratorOfElems();
        while (secondDom.hasNext()) {
            boolean result = false;
            GraphObject elem1 = secondDom.next();
            firstDom = theFirst.getOriginal().iteratorOfElems();
            while (firstDom.hasNext()) {
                GraphObject elem2 = firstDom.next();
                if (elem1.equals(elem2)) {
                    result = true;
                    break;
                }
            }
            if (!result) {
                return (result);
            }
        }

        // Zusicherung hier: theFirst und theSecond haben den
        // selben Definitionsbereich.
        // ----------------------------------------------------------------
        // Naechster Schritt: Untersuche weitere Anwendungsvoraussetzungen.
        // Kompositionseigenschaften von ``this''
        // (nur lesend, nicht schreibend) **/
        Iterator<GraphObject> ownDom = this.itsOrig.iteratorOfElems();
        while (ownDom.hasNext()) {
            GraphObject y = ownDom.next();
            GraphObject z = this.getImage(y);
            if (z != null) {
                Iterator<GraphObject> manyX = theFirst.getInverseImage(y);
                while (manyX.hasNext()) {
                    GraphObject x = manyX.next();
                    if (!theSecond.getImage(x).equals(z)) {
                        return false;
                    }
                }
            }
        }

        // Zusicherung hier: Wo this definiert ist, gilt die Gleichung
        // this(theFirst(x))=theSecond(x)=z
        // --------------------------------
        // Letzter Schritt: Vervollstaendigung von this (schreibend!)
        firstDom = theFirst.getOriginal().iteratorOfElems();
        while (firstDom.hasNext()) {
            GraphObject x = firstDom.next();
            GraphObject y = theFirst.getImage(x);
            GraphObject z = theSecond.getImage(x);
            if ((y != null) && (z != null)) {
                if (!z.equals(this.getImage(y))) {
                    try {
                        this.addMapping(y, z);
                    } catch (BadMappingException ex) {
                        return false;
                    }
                }
            }
        }

        return true;
    }

    /**
     * The current (this) morphism takes three morphisms, such that: this.source == theFirst.target, theSecond.source ==
     * theFirst.source, theThird.source == theSecond.target, this.target == theThird.target as input and this morphism
     * will be completed so that the diagram comutes: theFirst o this == theSecond o theThird .
     */
    //
    // [Graph X]---------------------->[Graph Y]
    //     |  \\          theFirst         |
    //     |     \\                        |
    //     |        \\                     |
    //  the|Second     \\                  |this
    //     |              \\               |
    //     |                 \\            |
    //     |                    \\         |
    //    \|/          theThird   _\|     \|/
    // [Graph J]---------------------->[Graph H]
    //
    //
    // -----------------------------------------------------------
    public boolean makeDiagram(final OrdinaryMorphism theFirst,
            final OrdinaryMorphism theSecond,
            final OrdinaryMorphism theThird) {
        // System.out.println(">>> OrdinaryMorphism.makeDiagram(1, 2, 3)");
        OrdinaryMorphism tmpMorph = theSecond.compose(theThird);

        return this.makeDiagram(theFirst, tmpMorph);
    }

    /**
     * <b>makeWeakDiagram</b>: fuer <em>DISAGG</em><br>
     * Der vorliegende Homomorphismus (this) nimmt drei weitere (theFirst, theSecond, theThird) als Input und wird
     * selbst so vervollstaendigt, dass Diagramm schwach kommutiert.
     */
    //
    // [Graph X]---------------------->[Graph Y]
    //    |     \         theFirst        |
    //    |        \                      |
    //    |           \                   |
    //    |theSecond     \                |this
    //    |                 \             |
    //    |                    \          |
    //    |                       \       |
    //   \|/          theThird      _\|  \|/
    // [Graph J]---------------------->[Graph H]
    //
    //
    // -----------------------------------------------------------
    public boolean makeWeakDiagram(final OrdinaryMorphism theFirst,
            final OrdinaryMorphism theSecond,
            final OrdinaryMorphism theThird) {
        OrdinaryMorphism tmpMorph = theSecond.compose(theThird);

        if (this.makeWeakDiagram(theFirst, tmpMorph)) {
            return true;
        }
        return false;
    }

    /**
     * Der vorliegende Homomorphismus (this) nimmt drei weitere (theFirst, theSecond, theThird) als Input und wird
     * selbst so vervollstaendigt, dass Diagramm kommutiert.
     */
    //
    // [Graph X]---------------------->[Graph Y]
    // 	  |      \\ 	  theFirst          |
    // 	  |         \\                      |
    //	  |            \\                   |
    //	  |theSecond      \\                |this
    //    |                  \\             |
    //    |                     \\          |
    //    |                        \\       |
    //   \|/           theThird      _\\|  \|/
    // [Graph J]---------------------->[Graph H]
    //
    //
    // -----------------------------------------------------------
    public boolean makeFullDiagram(final OrdinaryMorphism theFirst,
            final OrdinaryMorphism theSecond,
            final OrdinaryMorphism theThird) {
        // OrdinaryMorphism tmpMorph = theSecond.compose(theThird);
        OrdinaryMorphism tmpMorph = (BaseFactory.theFactory()).createMorphism(
                theSecond.getOriginal(), theThird.getImage());

        final Iterator<Node> theSecondDomNodes = theSecond.getOriginal().getNodesSet().iterator();
        while (theSecondDomNodes.hasNext()) {
            GraphObject theSecondGo = theSecondDomNodes.next();
            GraphObject theSecondGoImage = theSecond.getImage(theSecondGo);
            if (theSecondGoImage != null) {
                GraphObject theThirdGoImage = theThird.getImage(theSecondGoImage);
                if (theThirdGoImage != null) {
                    try {
                        tmpMorph.addMapping(theSecondGo, theThirdGoImage);
                    } catch (BadMappingException ex) {
                    }
                }
            }
        }
        final Iterator<Arc> theSecondDomArcs = theSecond.getOriginal().getArcsSet().iterator();
        while (theSecondDomArcs.hasNext()) {
            GraphObject theSecondGo = theSecondDomArcs.next();
            GraphObject theSecondGoImage = theSecond.getImage(theSecondGo);
            if (theSecondGoImage != null) {
                GraphObject theThirdGoImage = theThird.getImage(theSecondGoImage);
                if (theThirdGoImage != null) {
                    try {
                        tmpMorph.addMapping(theSecondGo, theThirdGoImage);
                    } catch (BadMappingException ex) {
                    }
                }
            }
        }

        if (this.makeFullDiagram(theFirst, tmpMorph)) {
            return true;
        }
        return false;
    }

    /**
     * Tries to complete this morphism to be isomorphic.
     */
    public boolean makeIsomorphic() {
        // vergleiche Knotenanzahl 
        if (this.itsOrig.getNodesCount() != this.itsImag.getNodesCount()) {
            return false;
        }
        // vergleiche Kantenanzahl
        if (this.itsOrig.getArcsCount() != this.itsOrig.getArcsCount()) {
            return false;
        }

        if (this.isTotal()) {
            return true;
        }

        boolean result = false;
        this.setCompletionStrategy(new Completion_InjCSP());
        if (this.nextCompletion()) {
            result = true;

 
        }
        return result;
    }

    public void setName(String n) {
        this.itsName = n;
    }

    public String getName() {
        return this.itsName;
    }

    /**
     * Set textual comments for this morphism.
     */
    public void setTextualComment(String text) {
        this.comment = text;
    }

    /**
     * Return textual comments of this morphism.
     */
    public String getTextualComment() {
        return this.comment;
    }

    /**
     * This method tries to add morphism mapping between elements of my source graph and elements of the specified list.
     * The elements of this list should be objects (nodes/edges) of my target graph. The order of the list has to be the
     * order of the graph objects of my source graph. It is allowed to put null element into this list. A morphism
     * mapping would be set for non-null elements only. As result a partial (total) graph morphism is done, if no errors
     * occured.
     */
    public void addMapping(final List<GraphObject> listOfGraphObjects)
            throws BadMappingException {
        // first set mapping of nodes
        final Iterator<Node> origs = this.itsOrig.getNodesSet().iterator();
        for (int i = 0; i < listOfGraphObjects.size() && origs.hasNext(); i++) {
            final GraphObject go = listOfGraphObjects.get(i);
            final GraphObject img = origs.next();
            if (go instanceof Node && img instanceof Node) {
                try {
                    addMapping(go, img);
                } catch (BadMappingException ex) {
                    throw ex;
                }
            }
        }
        // now set mapping of edges
        final Iterator<Arc> origs1 = this.itsOrig.getArcsSet().iterator();
        for (int i = 0; i < listOfGraphObjects.size() && origs1.hasNext(); i++) {
            final GraphObject go = listOfGraphObjects.get(i);
            final GraphObject img = origs1.next();
            if (go instanceof Arc && img instanceof Arc) {
                try {
                    addMapping(go, img);
                } catch (BadMappingException ex) {
                    throw ex;
                }
            }
        }
    }

    public void addMapping(final Hashtable<GraphObject, GraphObject> obj2img)
            throws BadMappingException {
        // first set mapping of nodes
        Iterator<GraphObject> objs = obj2img.keySet().iterator();
        while (objs.hasNext()) {
            final GraphObject obj = objs.next();
            if (obj.isNode()) {
                final GraphObject img = obj2img.get(obj);
                try {
                    addMapping(obj, img);
                } catch (BadMappingException ex) {
                    throw ex;
                }
            }
        }
        // now set mapping of edges
        objs = obj2img.keySet().iterator();
        while (objs.hasNext()) {
            final GraphObject obj = objs.next();
            if (obj.isArc()) {
                final GraphObject img = obj2img.get(obj);
                try {
                    addMapping(obj, img);
                } catch (BadMappingException ex) {
                    throw ex;
                }
            }
        }
    }

    /**
     * Returns an error if the type compatibility of the specified nodes failed, otherwise - null.
     */
    public TypeError checkCreateMapping(final Node src, final Node tar) {
        if (!checkType(src.getType(), tar.getType())) {
            this.errorMsg = "Objects to map must be of the compatible type.";
            return new TypeError(TypeError.NOT_COMPATIBLE_TYPE, this.errorMsg);
        } else if (this instanceof Match) {
            final Iterator<GraphObject> origEnum = getDomain();
            final Match m = (Match) this;
            while (origEnum.hasNext()) {
                final GraphObject currentObject = origEnum.next();
                if (currentObject instanceof Node && currentObject != src) {
                    final Node currentNode = (Node) currentObject;
                    final Node currentRuleImage = (Node) m.getRule().getImage(
                            currentNode);
                    final Node origRuleImage = (Node) m.getRule().getImage(src);
                    final Node currentMatchImage = (Node) m.getImage(currentNode);
                    if (currentRuleImage != null
                            && currentRuleImage == origRuleImage) {
                        if (currentMatchImage != null
                                && !tar.getType().compareTo(
                                        currentMatchImage.getType())) {
                            this.errorMsg = "Non-injective rules must preserve types.";
                            return new TypeError(TypeError.NOT_COMPATIBLE_TYPE,
                                    this.errorMsg);
                        }
                    }
                }
            }
        }
        return null;
    }

    /**
     * Returns null if the source and target nodes of the specified edges are already mapped and the type compatibility
     * of these two edges is satisfied, otherwise - an error.
     */
    public TypeError checkCreateMapping(final Arc src, final Arc tar) {
        final GraphObject aSrc = src.getSource();
        final GraphObject aTar = src.getTarget();
        if (!src.getType().compareTo(tar.getType())) {
            this.errorMsg = "Objects to map must be of the same type.";
            return new TypeError(TypeError.NOT_COMPATIBLE_TYPE, this.errorMsg);
        }
        if (getImage(aSrc) != null) {
            if (!checkType(tar.getSource().getType(), getImage(aSrc).getType())) {
                this.errorMsg = "Edge mapping must be source compatible.";
                return new TypeError(TypeError.NOT_COMPATIBLE_TYPE, this.errorMsg);
            }
        } else {
            this.errorMsg = "The sources of the edges should be already mapped.";
            return new TypeError(TypeError.NOT_COMPATIBLE_TYPE, this.errorMsg);
        }
        if (getImage(aTar) != null) {
            if (!checkType(tar.getTarget().getType(), getImage(aTar).getType())) {
                this.errorMsg = "Edge mapping must be target compatible.";
                return new TypeError(TypeError.NOT_COMPATIBLE_TYPE, this.errorMsg);
            }
        } else {
            this.errorMsg = "The targets of the edges should be already mapped.";
            return new TypeError(TypeError.NOT_COMPATIBLE_TYPE, this.errorMsg);
        }
        return null;
    }

    /**
     * Please note: This method is only for internal use of the critical pair analysis for grammars with node type
     * inheritance. Do not use it for any kind of implementations.
     *
     * @param o is a child node
     * @param i is a parent node
     * @throws BadMappingException
     */
    public void addChild2ParentMapping(final GraphObject o, final GraphObject i)
            throws BadMappingException {
        if (this.getImage(o) != i) {
            if (this.getSource().isElement(o) && this.getTarget().isElement(i)) {
                try {
                    if (o.isNode() != i.isNode()) {
                        this.errorMsg = "Cannot map a node to an edge.";
//						this.errors.add(this.errorMsg);
                        throw new BadMappingException(this.errorMsg);
                    }
                    if (!o.getType().isParentOf(i.getType())
                            && !o.getType().isChildOf(i.getType())) {
                        this.errorMsg = "Objects to map must to have compatible types.";
//						this.errors.add(this.errorMsg);
                        throw new BadMappingException(this.errorMsg);
                    }
                    try {
                        this.checkNodeTypePreserving(o, i);
                    } catch (BadMappingException ex) {
                        throw new BadMappingException(this.errorMsg);
                    }
                    try {
                        this.checkEdgeSourceTargetCompatibility(o, i);
                    } catch (BadMappingException ex) {
                        throw new BadMappingException(this.errorMsg);
                    }
                    final GraphObject aPreviousImage = getImage(o);
                    if (aPreviousImage != null) {
                        removeMapping(o);
                    }

                    // try to add attribute mapping
                    try {
                        this.doAddChild2ParentAttrMapping(o, i);
//						System.out.println(">>> "+o+" --> " +i);
                    } catch (BadMappingException exc) {
                        this.errorMsg = exc.getMessage();
//						this.errors.add(this.errorMsg);
                        // restore previous mapping, if any:
                        if (aPreviousImage != null) {
                            this.doAddChild2ParentAttrMapping(o, aPreviousImage);
                        }
                        // Beware! This does not restore the mappings which may have been
                        // removed IMPLICITLY above...
                        throw (exc);
                    }
                } catch (BadMappingException exc) {
                    this.errorMsg = exc.getMessage();
//					this.errors.add(this.errorMsg);
                    throw exc;
                }
//				System.out.println(">>> OrdinaryMorphism.addChild2ParentMapping   OK");
            }
        } else {
//			System.out.println("not needed to set the same graph object mapping! only add AttrMapping!");
            // attr mapping has to get update
            removeAttrMapping(o.getAttribute());
            addAttrMapping(o.getAttribute(), i.getAttribute());
        }
    }

    /**
     * Please note: This method is only for internal use of the critical pair analysis for grammars with node type
     * inheritance. Do not use it for any kind of implementations.
     *
     * @param orig is a child node
     * @param image is a parent node
     * @throws BadMappingException
     */
    private void doAddChild2ParentAttrMapping(final GraphObject orig, final GraphObject image)
            throws BadMappingException {
        if (((ContextView) getAttrContext()).getAllowedMapping() == AttrMapping.MATCH_MAP
                || ((ContextView) getAttrContext()).getAllowedMapping() == AttrMapping.OBJECT_FLOW_MAP) {
//System.out.println("OrdinaryMorphism.doAddChild2ParentAttrMapping  AttrMapping.MATCH_MAP");
            if ((orig.getAttribute() == null && image.getAttribute() == null)
                    || orig.getType().isChildOf(image.getType())
                    || ((orig.getAttribute() != null)
                    && ((ValueTuple) orig.getAttribute()).canMatchTo(
                            ((ValueTuple) image.getAttribute()),
                            (ContextView) getAttrContext()))) {
                boolean canMapAttr = true;
                if (orig.getType().isChildOf(image.getType())
                        && ((orig.getAttribute() != null)
                        && !((ValueTuple) orig.getAttribute()).canMatchChild2Parent(
                                ((ValueTuple) image.getAttribute()),
                                (ContextView) getAttrContext()))) {
                    canMapAttr = false;
                }

                if (canMapAttr) {
                    try {
                        addAttrMapping(orig.getAttribute(), image.getAttribute());
                    } catch (BadMappingException ex) {
                        this.errorMsg = "Attribute mapping failed!";
//						this.errors.add(this.errorMsg);
                        throw new BadMappingException(this.errorMsg);
                    }

                    addDomainMapping(orig, image, true);
                } else {
                    this.errorMsg = "Attribute mapping failed!";
//					this.errors.add(this.errorMsg);
//					System.out.println("## doAddChild2ParentAttrMapping: errorMsg: "+this.errorMsg);
                    throw new BadMappingException(this.errorMsg);
                }
            } else {
                this.errorMsg = "Attribute mapping failed!";
//				this.errors.add(this.errorMsg);
//				System.out.println("### doAddChild2ParentAttrMapping: errorMsg: "+this.errorMsg);
                throw new BadMappingException(this.errorMsg);
            }
        } else {
            if (!orig.getType().isChildOf(image.getType())) {
                addAttrMapping(orig.getAttribute(), image.getAttribute());

                addDomainMapping(orig, image, true);
            }
        }
    }

    /**
     * @param orig belongs to the source graph of this
     * @param image belongs to the target graph of this
     */
    private void addDomainMapping(final GraphObject orig, final GraphObject image, boolean notificationRequired) {
        this.itsDomObjects.add(orig);
        this.itsCodomObjects.add(image);
        this.mappingChanged = true;

        if (notificationRequired) {
            if (isNotificationRequired()) {
                propagateChange(new Change(Change.MAPPING_ADDED, orig, this));
                propagateChange(new Change(Change.MAPPING_ADDED, image, this));
            }
            if (this.itsOrig.isNotificationRequired()) {
                this.itsOrig.propagateChange(new Change(
                        Change.MAPPING_ADDED, orig, this));
            }
            if (this.itsImag.isNotificationRequired()) {
                this.itsImag.propagateChange(new Change(
                        Change.MAPPING_ADDED, image, this));
            }
        }
    }

    /**
     * Map an object of source graph to an object of target graph. The original and image objects have to belong to the
     * same morphism.
     *
     * <p>
     * <b>Pre:</b>
     * <ol>
     *
     * <li><code>o</code> is an element of <code>getOriginal()</code>.
     *
     * <li><code>i</code> is an element of <code>getImage()</code>.
     *
     * </ol> *
     *
     * @param o the source object of the mapping.
     *
     * @param i the target object of the mapping.
     *
     * @exception agg.xt_basis.BadMappingException if the given mapping violates morphism properties. *
     */
    public void addMapping(final GraphObject o, final GraphObject i)
            throws BadMappingException {
        if (o == null || i == null) {
            this.errorMsg = "Mapping failed! The source or target object is null.";
            throw new BadMappingException(this.errorMsg);
        }

        if (this.getImage(o) != i) {
            if (this.getSource().isElement(o) && this.getTarget().isElement(i)) {
                try {
                    doAddMapping(o, i);
                } catch (BadMappingException exc) {
                    this.errorMsg = exc.getMessage();
//					this.errors.add(this.errorMsg);
                    throw exc;
                }
            } else {
                this.errorMsg = "Mapping failed! Graph objects to map must belong to the same morphism.";
//				this.errors.add(this.errorMsg);
                throw new BadMappingException(this.errorMsg);
            }
        } else {
            // attr mapping has to get update
            removeAttrMapping(o.getAttribute());
            addAttrMapping(o.getAttribute(), i.getAttribute());
        }
    }

    /**
     * The user of this method must take care about any checks for the mapping of the specified graph objects. Otherwise
     * is null pointer exception can be thrown.
     *
     * @param o
     * @param i
     * @throws BadMappingException
     */
    public void addMappingFast(final GraphObject o, final GraphObject i)
            throws BadMappingException {
        if (o == null || i == null) {
            this.errorMsg = "Mapping failed! The source or target object is null.";
            throw new BadMappingException(this.errorMsg);
        }

        if (this.getImage(o) != i) {
            try {
                doAddMappingFast(o, i);
            } catch (BadMappingException exc) {
                this.errorMsg = exc.getMessage();
//				this.errors.add(this.errorMsg);
                throw exc;
            }
        } else {
            // attr mapping has to get update
            removeAttrMapping(o.getAttribute());
            addAttrMapping(o.getAttribute(), i.getAttribute());
        }
    }

    /*
	 * The user of this method must take care about any checks. 
	 * Otherwise null pointer exception woll be throwen.
     */
    private void doAddMappingFast(final GraphObject orig, final GraphObject image)
            throws BadMappingException {

        // try to add attribute mapping
        try {
            this.doAddAttrMappingFast(orig, image);
            this.addDomainMapping(orig, image, true);
            this.changed = true;
        } catch (BadMappingException exc) {
            this.errorMsg = exc.getMessage();
//			this.errors.add(this.errorMsg);			
            throw (exc);
        }
    }

    /*
	 * The user of this method must take care about any checks. 
	 * Otherwise null pointer exception woll be throwen.
     */
    private void doAddAttrMappingFast(final GraphObject orig, final GraphObject image)
            throws BadMappingException {
        if (((ContextView) getAttrContext()).getAllowedMapping() == AttrMapping.MATCH_MAP) {
            try {
                addAttrMapping(orig.getAttribute(), image.getAttribute());
            } catch (BadMappingException ex) {
                this.errorMsg = "Attribute mapping failed! " + ex.getLocalizedMessage();
//				this.errors.add(this.errorMsg);
                throw new BadMappingException(this.errorMsg);
            }
        } else {
            addAttrMapping(orig.getAttribute(), image.getAttribute());
        }
    }

    /**
     * Add PLAIN morphism mapping without any checks. <br>
     * Preconditions: <br>
     * - to map Node to Node and Arc to Arc only,<br>
     * - objects to map must be of the same type, <br>
     * - source and target of an edge must be already mapped.
     *
     */
    protected void addPlainMapping(final GraphObject orig, final GraphObject image)
            throws BadMappingException {
        if (orig == null || image == null) {
            this.errorMsg = "Mapping failed! The source or target object is null.";
            throw new BadMappingException(this.errorMsg);
        }
        try {
            addAttrMapping(orig.getAttribute(), image.getAttribute());
            addDomainMapping(orig, image, false);
            this.changed = true;
        } catch (BadMappingException exc) {
            this.errorMsg = exc.getMessage();
//			this.errors.add(this.errorMsg);
            throw exc;
        }
    }

    /**
     * Try to add a mapping of two GraphObjects without setting the attr mapping.
     *
     * @param orig
     * @param image
     * @throws BadMappingException
     */
    protected void addObjectPlainMapping(final GraphObject orig, final GraphObject image)
            throws BadMappingException {
        if (orig == null || image == null) {
            this.errorMsg = "Mapping failed! The source or target object is null.";
            throw new BadMappingException(this.errorMsg);
        }
        try {
//			addAttrMapping(orig.getAttribute(), image.getAttribute());				
            addDomainMapping(orig, image, false);
            this.changed = true;
        } catch (BadMappingException exc) {
            this.errorMsg = exc.getMessage();
//			this.errors.add(this.errorMsg);
            throw exc;
        }
    }

    protected boolean checkType(Type orig, Type image) {
        return orig.isParentOf(image);
    }

    private void checkNodeTypePreserving(final GraphObject orig, final GraphObject image)
            throws BadMappingException {
        if (this instanceof Match && orig.isNode()) {
            final Iterator<GraphObject> origEnum = getDomain();
            final Match m = (Match) this;
            while (origEnum.hasNext()) {
                final GraphObject currentObject = origEnum.next();
                if (currentObject instanceof Node && currentObject != orig) {
                    final Node currentNode = (Node) currentObject;
                    final Node currentRuleImage = (Node) m.getRule().getImage(
                            currentNode);
                    final Node origRuleImage = (Node) m.getRule().getImage(orig);
                    final Node currentMatchImage = (Node) m.getImage(currentNode);
                    if (currentRuleImage != null
                            && currentRuleImage == origRuleImage) {
                        if (currentMatchImage != null
                                && !image.getType().compareTo(
                                        currentMatchImage.getType())) {
                            this.errorMsg = "Non-injective rules must preserve types.";
//							this.errors.add(this.errorMsg);
                            throw new BadMappingException(this.errorMsg);
                        }
                    }
                }
            }
        }
    }

    protected void checkEdgeSourceTargetCompatibility(final GraphObject orig, final GraphObject image)
            throws BadMappingException {
        try {
            MatchHelper.checkEdgeSourceTargetCompatibility(this, orig, image);
        } catch (BadMappingException ex) {
            throw ex;
        }
    }

    private void doAddAttrMapping(final GraphObject orig, final GraphObject image)
            throws BadMappingException {
        if (((ContextView) getAttrContext()).getAllowedMapping() == AttrMapping.MATCH_MAP) {
            if ((orig.getAttribute() == null
                    || orig.getAttribute().getNumberOfEntries() == 0)
                    || (image.getAttribute() != null
                    && ((ValueTuple) orig.getAttribute())
                            .canMatchTo(
                                    ((ValueTuple) image.getAttribute()),
                                    (ContextView) getAttrContext()))) {
                addAttrMapping(orig.getAttribute(), image.getAttribute());
            } else {
                this.errorMsg = "Attribute mapping failed!";
//				this.errors.add(this.errorMsg);
                throw new BadMappingException(this.errorMsg);
            }
        } else {
            addAttrMapping(orig.getAttribute(), image.getAttribute());
        }
    }

    private void doAddMapping(final GraphObject orig, final GraphObject image)
            throws BadMappingException {
        if (orig.isNode() != image.isNode()) {
            this.errorMsg = "Cannot map node to edge.";
//			this.errors.add(this.errorMsg);
            throw new BadMappingException(this.errorMsg);
        }

        if (!checkType(orig.getType(), image.getType())) {
            this.errorMsg = "Objects to map must be of the same type.";
//			this.errors.add(this.errorMsg);
            throw new BadMappingException(this.errorMsg);
        }

        try {
            this.checkNodeTypePreserving(orig, image);
        } catch (BadMappingException ex) {
            throw new BadMappingException(this.errorMsg);
        }

        try {
            this.checkEdgeSourceTargetCompatibility(orig, image);
        } catch (BadMappingException ex) {
            this.errorMsg = ex.getLocalizedMessage();
            throw new BadMappingException(this.errorMsg);
        }
        // store previous image of orig
        final GraphObject aPreviousImage = getImage(orig);
        if (aPreviousImage != null) {
            removeMapping(orig);
        }

        // try to add attribute mapping
        try {
            this.doAddAttrMapping(orig, image);
            this.addDomainMapping(orig, image, true);
            this.changed = true;

        } catch (BadMappingException exc) {
            this.errorMsg = exc.getMessage();
//			this.errors.add(this.errorMsg);
            // restore previous mapping, if any:
            if (aPreviousImage != null) {
                addMappingFast(orig, aPreviousImage);
            }
            // Beware! This does not restore the mappings which may have been
            // removed IMPLICITLY above...
            throw (exc);
        }
    }

    protected void addAttrMapping(final AttrInstance o, final AttrInstance i)
            throws BadMappingException {
        if (getAttrContext() == null) {
            return;
        }
        if (o == null && i == null) {
            return;
        }
        if (o != null && i != null) {
            try {
                this.itsAttrMappings.put(o, getAttrManager().newMapping(
                        getAttrContext(), o, i));
                this.errorMsg = "";
                // System.out.println("OrdinaryMorphism.addAttrMapping --> Mapping added");
            } catch (AttrException exc) {
                this.errorMsg = exc.getMessage();
                // System.out.println("OrdinaryMorphism.addAttrMapping
                // FAILED! \n"+this.errorMsg);
                throw new BadMappingException(exc.getMessage());
            }
        } else if (o != null && o.getNumberOfEntries() != 0) {
            throw new BadMappingException(
                    "Attribute mapping failed! Attribute of source or target object is null.");
        }
    }

    protected boolean removeAttrMapping = true;

    protected void removeAttrMapping(final AttrInstance o) {
        if (o != null) {
            AttrMapping anAttrMapping = this.itsAttrMappings.get(o);
            if (anAttrMapping != null && this.removeAttrMapping) {
                anAttrMapping.remove();
                this.itsAttrMappings.remove(o);
            }
        }
    }

    public void removeVariableValue(final AttrInstance o) {
        if (o == null) {
            return;
        }
        final ValueTuple vt = (ValueTuple) o;
        for (int i = 0; i < vt.getNumberOfEntries(); i++) {
            ValueMember vm = vt.getValueMemberAt(i);
            if (vm.isSet() && vm.getExpr().isVariable()) {
                final VarTuple vars = (VarTuple) this.itsAttrContext.getVariables();
                final VarMember var = vars.getVarMemberAt(vm.getExprAsText());
                if (!var.isInputParameter()) {
                    var.setExpr(null);
                }
            }
        }
    }

    public void updateAttrMappings() {
        if (!this.itsImag.isAttributed()) {
            return;
        }

        for (int i = 0; i < this.itsDomObjects.size(); i++) {
            final GraphObject obj = this.itsDomObjects.get(i);
            final GraphObject img = this.itsCodomObjects.get(i);
            removeAttrMapping(obj.getAttribute());
            addAttrMapping(obj.getAttribute(), img.getAttribute());
        }
    }

    /**
     * This method should be used after the method <code>removeMapping(GraphObject go)</code> called and befor the
     * method <code>nextCompletion(Iterator varnodes, Iterator varedges)</code> performed.
     *
     * @param go is an element of my source graph
     */
    public void resetCSPVariableDomainOf(GraphObject go) {
        if (this.itsOrig.isElement(go)) {
            this.itsCompleter.resetVariableDomain(go);
        }
    }

    public void removeAllMappings() {
        removeAttrMappings();
        this.itsDomObjects.clear();
        this.itsCodomObjects.clear();
        this.mappingChanged = false;
    }

    /**
     * Returns TRUE if removed, otherwise - FALSE
     */
    public boolean removeMapping(final Node src, final Node tar) {
        if (this.getSource().isElement(src) && this.getTarget().isElement(tar)) {
            int i = this.itsDomObjects.indexOf(src);
            int j = this.itsCodomObjects.indexOf(tar);
            if (i >= 0 && j >= 0) {
                if (i != j && this.itsDomObjects.get(j) == src) {
                    i = j;
                }

                if (i == j) {
                    GraphObject aNeighbor;
                    Iterator<Arc> anIter = src.getIncomingArcsSet().iterator();
                    while (anIter.hasNext()) {
                        aNeighbor = anIter.next();
                        if (getImage(aNeighbor) != null) {
                            removeMapping(aNeighbor);
                        }
                    }
                    anIter = src.getOutgoingArcsSet().iterator();
                    while (anIter.hasNext()) {
                        aNeighbor = anIter.next();
                        if (getImage(aNeighbor) != null) {
                            removeMapping(aNeighbor);
                        }
                    }
                    // update the index of Node src
                    i = this.itsDomObjects.indexOf(src);
                    j = this.itsCodomObjects.indexOf(tar);
                    if (i != j && this.itsDomObjects.get(j) == src) {
                        i = j;
                    }

                    if (i == j) {
                        removeAttrMapping(src.getAttribute());
                        removeDomainMapping(i, true);
                        return true;
                    }
                }
            }
        }
        return false;
    }

    /**
     * @param i index of a graph object inside of this.itsDomObjects
     */
    private void removeDomainMapping(int i, boolean notificationRequired) {
        final GraphObject dom = this.itsDomObjects.get(i);
        this.itsDomObjects.remove(i);
        final GraphObject codom = this.itsCodomObjects.get(i);
        this.itsCodomObjects.remove(i);
        this.mappingChanged = true;

        if (notificationRequired) {
            if (isNotificationRequired()) {
                propagateChange(new Change(Change.MAPPING_REMOVED, dom, this));
                propagateChange(new Change(Change.MAPPING_REMOVED, codom, this));
            }
            if (this.itsOrig.isNotificationRequired()) {
                this.itsOrig.propagateChange(new Change(Change.MAPPING_REMOVED, dom,
                        this));
            }
            if (this.itsImag.isNotificationRequired()) {
                this.itsImag.propagateChange(new Change(Change.MAPPING_REMOVED,
                        codom, this));
            }
        }
    }

    /**
     * Returns TRUE if removed, otherwise - FALSE. Note: The source and target nodes of the specified src and tar edges
     * still mapped. They should be removed explicitly.
     */
    public boolean removeMapping(final Arc src, final Arc tar) {
        if (this.getSource().isElement(src) && this.getTarget().isElement(tar)) {
            int i = this.itsDomObjects.indexOf(src);
            int j = this.itsCodomObjects.indexOf(tar);
            if (i >= 0 && j >= 0) {
                if (i != j && this.itsDomObjects.get(j) == src) {
                    i = j;
                }

                if (i == j) {
                    removeAttrMapping(src.getAttribute());
                    removeDomainMapping(i, true);
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Remove the mapping of the given GraphObject. In case of node, any mappings of incoming / outgoing arcs will be
     * removed as well.
     *
     */
    public void removeMapping(final GraphObject o) {
        if (this.getSource().isElement(o)) {
            doRemoveMapping(o);
        } else if (this.getTarget().isElement(o)) {
            final Iterator<GraphObject> en = getInverseImage(o);
            while (en.hasNext()) {
                doRemoveMapping(en.next());
            }
        }
    }

    /**
     * Remove the mapping of the given GraphObject. In case of node, any mappings of incoming / outgoing arcs will be
     * removed as well. Precondition: <br>
     * - if left is true, the obj belongs to the source graph - if left is false, the obj belongs to the target graph
     */
    public void removeMappingFast(final GraphObject obj, boolean left) {
        if (left) {
            doRemoveMapping(obj);
        } else {
            final Iterator<GraphObject> en = getInverseImage(obj);
            while (en.hasNext()) {
                doRemoveMapping(en.next());
            }
        }
    }

    private void doRemoveMapping(final GraphObject o) {
        int i = this.itsDomObjects.indexOf(o);
        if (i >= 0) {
            if (o.isNode()) {
                GraphObject aNeighbor;
                Iterator<Arc> anIter = ((Node) o).getIncomingArcsSet().iterator();
                while (anIter.hasNext()) {
                    aNeighbor = anIter.next();
                    if (getImage(aNeighbor) != null) {
                        doRemoveMapping(aNeighbor);
                    }
                }
                anIter = ((Node) o).getOutgoingArcsSet().iterator();
                while (anIter.hasNext()) {
                    aNeighbor = anIter.next();
                    if (getImage(aNeighbor) != null) {
                        doRemoveMapping(aNeighbor);
                    }
                }

                // update the index of Node o
                i = this.itsDomObjects.indexOf(o);
            }

            removeAttrMapping(o.getAttribute());

            removeDomainMapping(i, true);
        }
    }

    /**
     * Remove all mappings and reset variables of its attribute context.
     */
    public void clear() {
        if (this.itsCoMorph != null) {
            this.itsCoMorph.dispose();
        }
        removeAllMappings();

        if (this.itsAttrContext.getVariables().getNumberOfEntries() != 0) {
            ((ContextView) this.itsAttrContext).resetVariableTuple();
            ((ContextView) this.itsAttrContext).resetConditionTuple();

//			((VarTuple) itsAttrContext.getVariables()).getContext().removeAllMappings();
//			((CondTuple) itsAttrContext.getConditions()).getContext().removeAllMappings();		
//			((VarTuple) itsAttrContext.getVariables()).updateByParent();
//			((VarTuple) itsAttrContext.getVariables()).unsetNotInputVariables();
        }

        this.mappingChanged = false;
        this.partialMorphCompletion = false;
        clearErrorMsg();
    }

    public void removeAttrMappings() {
        final Iterator<AttrInstance> keys = this.itsAttrMappings.keySet().iterator();
        while (keys.hasNext()) {
            AttrInstance key = keys.next();
            key.getContext().removeAllMappings();
        }
        ((Hashtable<AttrInstance, AttrMapping>) this.itsAttrMappings).clear();

        this.itsAttrContext.removeAllMappings();
    }

    /**
     * Return true if its morphism mapping is empty, otherwise - false.
     */
    public boolean isEmpty() {
        return this.itsDomObjects.isEmpty();
    }

    /**
     * Return its source graph.
     */
    @Override
    public Graph getOriginal() {
        return this.itsOrig;
    }

    /**
     * Return its source graph.
     */
    public Graph getSource() {
        return this.itsOrig;
    }

    /**
     * Return its target graph.
     */
    @Override
    public Graph getImage() {
        return this.itsImag;
    }

    /**
     * Return its target graph.
     */
    public Graph getTarget() {
        return this.itsImag;
    }

    public List<GraphObject> getDomainObjects() {
        return this.itsDomObjects;
    }

    /**
     * Return the objects of my source graph which are actually taking part in the current morphism mappings.
     */
    @Override
    public Iterator<GraphObject> getDomain() {
        return this.itsDomObjects.iterator();
    }

    public int getDomainSize() {
        return this.itsDomObjects.size();
    }

    /**
     * Return the objects of my target graph which are actually taking part in the current morphism mappings.
     */
    @Override
    public Iterator<GraphObject> getCodomain() {
        return this.itsCodomObjects.iterator();
    }

    public List<GraphObject> getCodomainObjects() {
        return this.itsCodomObjects;
    }

    public int getCodomainSize() {
        return this.itsCodomObjects.size();
    }

    /**
     * *************************************************************************
     * Return the image of the specified object.
     *
     * @return <code>null</code> if the object is not in domain.*
     * ************************************************************************
     */
    @Override
    public GraphObject getImage(final GraphObject o) {
        int i = this.itsDomObjects.indexOf(o);
        if ((i > -1) && (i < this.itsCodomObjects.size())) {
            return this.itsCodomObjects.get(i);
        }
        return null;
    }

    /**
     * Return an Iterator of the inverse images of the specified object. Iterator will be empty when the object is not
     * in codomain. Iterator elements are of type <code>GraphObject</code>.
     */
    @Override
    public Iterator<GraphObject> getInverseImage(final GraphObject o) {
        return getInverseImageList(o).iterator();
    }

    @Override
    public GraphObject firstOfInverseImage(GraphObject o) {
        return this.itsDomObjects.get(this.itsCodomObjects.indexOf(o));
    }

    @Override
    public boolean hasInverseImage(GraphObject o) {
        return this.itsCodomObjects.contains(o);
        // dann waere ja etwas aus this.itsDomObjects zu holen gewesen.
    }

    public List<GraphObject> getInverseImageList(final GraphObject o) {
        final List<GraphObject> invImages = new ArrayList<>();
        final int[] i = {0};
        this.itsCodomObjects.forEach(codo -> {
            if (codo.equals(o)) {
                invImages.add(this.itsDomObjects.get(i[0]));
            }
            i[0]++;
        });
        return invImages;
    }

    public List<GraphObject> getElementsToCreate() {
        final List<GraphObject> created = findCreatedElements();
        return created;
    }

    public List<GraphObject> getElementsToDelete() {
        final List<GraphObject> deleted = findDeletedElements();
        return deleted;
    }

    public Hashtable<GraphObject, GraphObject> morphToMap() {
        final Hashtable<GraphObject, GraphObject> map = new Hashtable<GraphObject, GraphObject>();
        final Iterator<GraphObject> dom = this.getDomain();
        while (dom.hasNext()) {
            GraphObject obj = dom.next();
            map.put(obj, this.getImage(obj));
        }
        return map;
    }

    /**
     * Set the algorithm of morphism completion.Class <code>CompletionStrategySelector</code> provides a way to present
     * and obtain available algorithms.
     *
     * @param s
     * @see agg.xt_basis.CompletionStrategySelector
     */
    public void setCompletionStrategy(final MorphCompletionStrategy s,
            boolean rewrite) {
        if (rewrite) {
            if (this.itsCompleter == null || this.itsCompleter != s) {
                this.itsCompleter = s;
            }
        } else {
            setCompletionStrategy(s);
        }
    }

    /**
     * Set the algorithm of morphism completion.Class <code>CompletionStrategySelector</code> provides a way to present
     * and obtain available algorithms. The given strategy is internally cloned to prevent undesired side effects.
     *
     * @param s
     * @see agg.xt_basis.CompletionStrategySelector
     */
    public void setCompletionStrategy(final MorphCompletionStrategy s) {
        if (this.itsCompleter == null || !this.itsCompleter.equals(s)) {
            this.itsCompleter = (MorphCompletionStrategy) s.clone();
        }
    }

    public final MorphCompletionStrategy getCompletionStrategy() {
        return this.itsCompleter;
    }

    public void unsetCompletionStrategy() {
        this.itsCompleter = null;
    }

    /**
     * Return true if my source graph can be a subgraph of the given graph g basically. It can only work for INJECTIVE
     * search.
     */
    public boolean canMatch(final Graph g, final MorphCompletionStrategy strategy) {
        // check graph size if injective morphism
        if (strategy.getProperties().get(CompletionPropertyBits.INJECTIVE)) {
            if ((this.itsOrig.getNodesCount() > g.getNodesCount())
                    || (this.itsOrig.getArcsCount() > g.getArcsCount())) {
                return false;
            }
        }
        // check types: all types of the orig. graph should be in image, too
        final List<Type> origTypes = this.itsOrig.getUsedTypes();
        final List<Type> otherTypes = g.getUsedAndInheritedTypes();
        for (int i = 0; i < origTypes.size(); i++) {
            if (!otherTypes.contains(origTypes.get(i))) {
                return false;
            }
        }
        return true;
    }

    /**
     * Return true if this morphism can be completed basically.
     */
    public boolean canComplete() {
        // check graph size if injective morphism
        if (this.itsCompleter.getProperties().get(CompletionPropertyBits.INJECTIVE)) {
            if ((this.itsOrig.getNodesCount() > this.itsImag.getNodesCount())
                    || (this.itsOrig.getArcsCount() > this.itsImag.getArcsCount())) {
                return false;
            }
        }
        // check types: all types of the orig. graph should be in image, too
        final List<Type> origTypes = this.itsOrig.getUsedTypes();
        final List<Type> imagTypes = this.itsImag.getUsedAndInheritedTypes();
        for (int i = 0; i < origTypes.size(); i++) {
            if (!imagTypes.contains(origTypes.get(i))) {
                return false;
            }
        }
        return true;
    }

    public boolean isMappingChanged() {
        return this.mappingChanged;
    }

    /**
     * *************************************************************************
     * Compute next completion: * Invoke this method successively to get all completions.
     *
     * @return <code>false</code> if there are no more completions.*
     * ************************************************************************
     */
    public boolean nextCompletion() {
        boolean ok = false;
        this.errorMsg = "";
        ok = doNextCompletion();
        if (!ok) {
//			get error message from attribute manager
            String attrMsg = ((agg.attribute.impl.ContextView) this
                    .getAttrContext()).getManager().getErrorMsg();
            if (attrMsg.length() > 0) {
                this.errorMsg = attrMsg;
//				this.errors.add(this.errorMsg);
            }
//			else if (this.errorMsg.length()>0)
//				this.errors.add(this.errorMsg);
        }
        return ok;
    }

    /**
     * *************************************************************************
     * Compute next completion: * Invoke this method successively to get all completions for the nodes and edges
     * specified by the List varnodes and List varedges, only.
     *
     * @return <code>false</code> if there are no more completions.*
     * ************************************************************************
     */
    public boolean nextCompletion(
            Collection<Node> varnodes,
            Collection<Arc> varedges) {
        boolean ok = false;
        this.errorMsg = "";
        ok = doNextCompletion(varnodes, varedges);
        if (!ok) {
//			get error message from attribute manager
            String attrMsg = ((agg.attribute.impl.ContextView) this
                    .getAttrContext()).getManager().getErrorMsg();
            if (attrMsg.length() > 0) {
                this.errorMsg = attrMsg;
//				this.errors.add(this.errorMsg);
            }
//			else if (this.errorMsg.length()>0) 
//				this.errors.add(this.errorMsg);
        }
        return ok;
    }

    /**
     * Compute next completion: Invoke this method successively to get all completions.
     *
     * @return <code>false</code> if there are no more completions.
     */
    public boolean nextCompletionWithConstantsChecking(
            Collection<Node> varnodes,
            Collection<Arc> varedges) {

        // Diese Methode ist nur bei Instanzen von OrdinaryMorphism sinvoll.
        // Daraus folgt: Attribute Mappingsmode ist PLAIN_MAP.
        boolean found = false;
        while (!found && this.nextCompletion(varnodes, varedges)) {
            found = true;
            if (!this.checkConstants()) {
                this.errorMsg = "Mismatch of constant attribute values.";
//				this.errors.add(this.errorMsg);
                found = false;
            }
        }
        return found;
    }

    /**
     * Compute next completion: Invoke this method successively to get all completions.
     *
     * @return <code>false</code> if there are no more completions.
     */
    public boolean nextCompletionWithConstantsAndVariablesChecking(
            Collection<Node> varnodes,
            Collection<Arc> varedges) {

        // Diese Methode ist nur bei Instanzen von OrdinaryMorphism sinvoll.
        // Daraus folgt: Attribute Mappingsmode ist PLAIN_MAP.
        boolean found = false;
        while (!found && this.nextCompletion(varnodes, varedges)) {
            found = true;
            if (!this.checkAll()) {
                this.errorMsg = "Mismatch of constant attribute values or variables.";
//				this.errors.add(this.errorMsg);
                found = false;
            }
        }
        return found;
    }

    private boolean doNextCompletion() {
        if (this.itsTouchedFlag) {
            this.itsCompleter.reset();
            this.itsTouchedFlag = false;
        }
        this.mappingChanged = false;
        // temporarily turn off update processing:
        this.itsInteractiveFlag = false;
        boolean b = this.itsCompleter.next(this);
//		this.changed = this.changed || b;
        // turn update processing on again:
        this.itsInteractiveFlag = true;
        return b;
    }

    /**
     * Try to get completion using only nodes and edges specified by the List varnodes and List varedges.
     */
    private boolean doNextCompletion(
            Collection<Node> varnodes,
            Collection<Arc> varedges) {
        if (this.itsTouchedFlag) {
            this.itsCompleter.reset();
            this.itsTouchedFlag = false;
        }
        // temporarily turn off update processing:
        this.itsInteractiveFlag = false;
        boolean b = this.itsCompleter.next(this, varnodes, varedges);
//		this.changed = this.changed || b;
        // turn update processing on again:
        this.itsInteractiveFlag = true;
        return b;
    }

    /**
     * Compute next completion. Invoke this method successively to get all completions.
     *
     * @return <code>false</code> if there are no more completions.
     */
    public boolean nextCompletionWithConstantsChecking() {
        // Diese Methode ist nur bei Instanzen von OrdinaryMorphism sinvoll.
        // Attribute Mappingsmode ist PLAIN_MAP.
        boolean found = false;
        while (!found && this.nextCompletion()) {
            found = true;
            if (!this.checkConstants()) {
                this.errorMsg = "Mismatch of constant attribute values.";
//				this.errors.add(this.errorMsg);
                found = false;
            }
        }
        return found;
    }

    /**
     * Compute next completion. Invoke this method successively to get all completions.
     *
     * @return <code>false</code> if there are no more completions.
     */
    public boolean nextCompletionWithConstantsAndVariablesChecking() {
        // Diese Methode ist nur bei Instanzen von OrdinaryMorphism sinvoll.
        // Attribute Mappingsmode ist PLAIN_MAP.
        boolean found = false;
        while (!found && this.nextCompletion()) {
            found = true;
            if (!this.checkAll()) {
                this.errorMsg = "Mismatch of constant attribute values or variables.";
//				this.errors.add(this.errorMsg);
                found = false;
            }
        }
        return found;
    }

    /**
     * Return <code>true</code> if this is a total morphism.
     */
    public final boolean isTotal() {
        return this.itsOrig.isEmpty()
                || (this.itsOrig.getSize() == this.itsDomObjects.size());
    }

    /**
     * Return <code>true</code> if this is a right total morphism.
     */
    public boolean isRightTotal() {
        boolean res = false;
        if (this.itsCodomObjects.size() == this.itsImag.getSize()
                && this.itsCodomObjects.containsAll(this.itsImag.getNodesCollection())
                && this.itsCodomObjects.containsAll(this.itsImag.getArcsCollection())) {
            res = true;
        }
        return res;
    }

    public boolean doesIgnoreAttrs() {
        boolean res = true;
        for (int i = 0; i < this.itsDomObjects.size(); i++) {
            GraphObject obj = this.itsDomObjects.get(i);
            if (obj.getAttribute() == null) {
                continue;
            }

            GraphObject img = this.getImage(obj);
            ValueTuple imgVal = (ValueTuple) img.getAttribute();
            for (int j = 0; j < imgVal.getNumberOfEntries(); j++) {
                ValueMember vmImg = imgVal.getValueMemberAt(j);
                if (vmImg.isSet() && !vmImg.isTransient()) {
                    ValueMember vmObj = ((ValueTuple) obj.getAttribute()).getValueMemberAt(vmImg.getName());
                    if (vmObj != null && vmObj.isSet()
                            && vmObj.getExprAsText().equals(vmImg.getExprAsText())) {
                        res = false;
                        break;
                    }
                }
            }
        }
        return res;
    }

    /**
     * Return the attribute context that is used for attribute matching.
     *
     * @see agg.attribute.AttrContext
     */
    public AttrContext getAttrContext() {
        return this.itsAttrContext;
    }

    /**
     * Set the attribute context that is used for attribute matching.
     *
     * @see agg.attribute.AttrContext
     */
    public void setAttrContext(final AttrContext ac) {
        this.itsAttrContext = ac;
    }

    public Map<AttrInstance, AttrMapping> getAttrMapping() {
//		return (new Hashtable<AttrInstance, AttrMapping>())
//			.putAll((Hashtable<AttrInstance, AttrMapping>)this.itsAttrMappings);
        return this.itsAttrMappings;
    }

    public void reflectTransientOfSimilarVar(final VarTuple vars) {
        final VarTuple itsVars = (VarTuple) getAttrContext().getVariables();
        for (int i = 0; i < vars.getSize(); i++) {
            final VarMember var = vars.getVarMemberAt(i);
            final VarMember itsvar = itsVars.getVarMemberAt(var.getName());
            if (itsvar != null) {
                if (!itsvar.isTransient() && var.isTransient()) {
                    itsvar.setTransient(true);
                }
            }
        }
    }

    public void adaptAttrContextValues(final AttrContext ac) {
        // System.out.println("OrdinaryMorphism.adaptAttrContextValues...");
        final VarTuple itsVars = (VarTuple) this.getAttrContext().getVariables();
        final VarTuple vars = (VarTuple) ac.getVariables();
//		vars.showVariables();
        for (int i = 0; i < vars.getSize(); i++) {
            final VarMember var = vars.getVarMemberAt(i);
            final VarMember itsVar = itsVars.getVarMemberAt(var.getName());
            if (itsVar != null) {
                if (var.isSet()) {
//					itsVar.setExprAsText(var.getExprAsText());
                    itsVar.setExpr(var.getExpr());

                    // check if var itself uses another variable
                    final VarMember tmp = vars.getVarMemberAt(var.getExprAsText());
                    if (tmp != null && tmp.isTransient()) {
                        itsVar.setTransient(true);
                        var.setTransient(true);
                    }
                }
            }
        }
    }

    public void adaptAttrContextValuesFromExistingObjMapping() {
        for (int i = 0; i < this.itsDomObjects.size(); i++) {
            GraphObject obj = this.itsDomObjects.get(i);
            if (obj.getAttribute() == null) {
                continue;
            }

            GraphObject img = this.getImage(obj);
            ValueTuple imgVal = (ValueTuple) img.getAttribute();
            for (int j = 0; j < imgVal.getNumberOfEntries(); j++) {
                ValueMember vmImg = imgVal.getValueMemberAt(j);
                if (vmImg.isSet()) {
                    ValueMember vmObj = ((ValueTuple) obj.getAttribute()).getValueMemberAt(vmImg.getName());
                    if (vmObj != null && vmObj.isSet() && vmObj.getExpr().isVariable()) {
                        VarMember var = ((VarTuple) this.getAttrContext().getVariables())
                                .getVarMemberAt(vmObj.getExprAsText());
                        var.setExprAsText(vmImg.getExprAsText());
                    }
                }
            }
        }
    }

    public void addToAttrContextFromList(final List<VarMember> vars, boolean setInputParameter) {
        final VarTuple itsVars = (VarTuple) getAttrContext().getVariables();
        for (int i = 0; i < vars.size(); i++) {
            final VarMember var = vars.get(i);
            final DeclMember dm = (DeclMember) var.getDeclaration();
            if (!itsVars.isDeclared(dm.getTypeName(), dm.getName())) {
                itsVars.declare(dm.getHandler(),
                        dm.getTypeName(), dm.getName());
                itsVars.getVarMemberAt(dm.getName()).setTransient(var.isTransient());
                itsVars.getVarMemberAt(dm.getName()).setInputParameter(var.isInputParameter() || setInputParameter);
            }
        }
    }

    public void addToAttrContext(final VarTuple vars) {
        final VarTuple itsVars = (VarTuple) getAttrContext().getVariables();
        for (int i = 0; i < vars.getSize(); i++) {
            final VarMember var = vars.getVarMemberAt(i);
            final DeclMember dm = (DeclMember) var.getDeclaration();
            if (!itsVars.isDeclared(dm.getTypeName(), dm.getName())) {
                itsVars.declare(dm.getHandler(),
                        dm.getTypeName(), dm.getName());
                itsVars.getVarMemberAt(dm.getName()).setTransient(var.isTransient());
                itsVars.getVarMemberAt(dm.getName()).setInputParameter(var.isInputParameter());
            }
        }
    }

    public void addToAttrContextAccordingList(final VarTuple vars, final List<String> varNames) {
        if (varNames != null && !varNames.isEmpty()) {
            final VarTuple itsVars = (VarTuple) getAttrContext().getVariables();
            for (int i = 0; i < vars.getSize(); i++) {
                final VarMember var = vars.getVarMemberAt(i);
                if (varNames.contains(var.getName())) {
                    final DeclMember dm = (DeclMember) var.getDeclaration();
                    if (!itsVars.isDeclared(dm.getTypeName(), dm.getName())) {
                        itsVars.declare(dm.getHandler(),
                                dm.getTypeName(), dm.getName());
                        itsVars.getVarMemberAt(dm.getName()).setTransient(var.isTransient());
                        itsVars.getVarMemberAt(dm.getName()).setInputParameter(var.isInputParameter());
                    }
                }
            }
        }
    }

    public void addToAttrContext(final CondTuple conds) {
        final CondTuple itsConds = (CondTuple) getAttrContext().getConditions();
        for (int i = 0; i < conds.getSize(); i++) {
            final CondMember cond = conds.getCondMemberAt(i);
            if (!itsConds.contains(cond.getExprAsText())) {
                itsConds.addCondition(cond.getExprAsText());
            }
        }
    }

    public void addToAttrContext(final AttrContext ac) {
        this.addToAttrContext((VarTuple) ac.getVariables());
        this.addToAttrContext((CondTuple) ac.getConditions());
    }

    public final AttrManager getAttrManager() {
        return this.itsAttrManager;
    }

    // protected synchronized void setChanged()
    public synchronized void setChanged() {
        if (this.itsInteractiveFlag) {
            this.itsTouchedFlag = true;
        }
        // force initialization of morphism completion when nextCompletion()
        // is called.
        super.setChanged();
    }

    public void writeMorphism(XMLHelper h) {
        h.openSubTag("Morphism");
        h.addAttr("name", this.itsName);

        if (!this.comment.equals("")) {
            h.addAttr("comment", this.comment);
        }

        Iterator<GraphObject> e = getDomain();
        while (e.hasNext()) {
            GraphObject s = e.next();

            h.openSubTag("Mapping");
            h.addObject("orig", s, false);
            h.addObject("image", getImage(s), false);
            h.close();
        }
        h.close();
    }

    public void readMorphism(XMLHelper h) {
        if (h.readSubTag("Morphism")) {
            String str = h.readAttr("name");
            setName(str.replaceAll(" ", ""));
            // setName(h.readAttr("name"));
            str = h.readAttr("comment");
            if (!str.equals("")) {
                this.comment = str.toString();
            }

            Hashtable<GraphObject, GraphObject> map = new Hashtable<GraphObject, GraphObject>();
            while (h.readSubTag("Mapping")) {
                GraphObject o = (GraphObject) h.getObject("orig", null, false);
                GraphObject i = (GraphObject) h.getObject("image", null, false);

                if (o != null && i != null) {
                    if (o instanceof Node) {
                        try {
                            addMapping(o, i);
                        } catch (BadMappingException ex) {
                        }
                    } else {
                        map.put(o, i);
                    }
                }
                h.close();
            }
            h.close();

            Iterator<GraphObject> en = map.keySet().iterator();
            while (en.hasNext()) {
                GraphObject o = en.next();
                GraphObject i = map.get(o);
                GraphObject s = ((Arc) o).getSource();
                GraphObject t = ((Arc) o).getTarget();
                if (o instanceof UndirectedArc) {
                    if (((((UndirectedArc) i).getSource() == getImage(s))
                            && (((UndirectedArc) i).getTarget() == getImage(t)))
                            || ((((UndirectedArc) i).getTarget() == getImage(s))
                            && (((UndirectedArc) i).getSource() == getImage(t)))) {
                        try {
                            addMapping(o, i);
                        } catch (BadMappingException ex) {
                        }
                    }
                } else if ((((Arc) i).getSource() == getImage(s))
                        && (((Arc) i).getTarget() == getImage(t))) {
                    try {
                        addMapping(o, i);
                    } catch (BadMappingException ex) {
                    }
                }
            }
        }
    }

    /*
	 * Create and return a new submorphism. It is automatically added to my set *
	 * of submorphisms. The new submorphism and its image and * original graphs
	 * which are newly created are initially empty. *
	 * <p>
	 * Note that the newly created image and original subgraphs are not *
	 * automatically removed when the submorphism itself is destroyed.
     */
//	public final OrdinarySubMorphism createSubMorphism()
//	{
//		OrdinarySubMorphism aSubMorph = new OrdinarySubMorphism(this, this
//				.getOriginal().createSubGraph(), this.getImage()
//				.createSubGraph());
//		itsSubMorphs.add(aSubMorph);
//		return aSubMorph;
//	}

    /*
	 * Create and return a new submorphism. It is automatically added to my set *
	 * of submorphisms. The new submorphism's image and original graphs are set *
	 * to be <code>orig</code> and <code>img</code>, respectively. The
	 * submorphism * is filled so that it maps all the objects of
	 * <code>orig</code> in the same * way I do.
	 * <p>
	 * <b>Pre:</b>
	 * <ol> *
	 * <li> <code>orig</code> is subgraph of <code>this.getOriginal()</code>. *
	 * <li> <code>img</code> is subgraph of <code>this.getImage()</code>.
	 * </ol>
     */
//	public final OrdinarySubMorphism createSubMorphism(SubGraph orig,
//			SubGraph img)
//	{
//		OrdinarySubMorphism aSubMorph = new OrdinarySubMorphism(this, orig, img);
//
    ////		if (itsSubMorphs == null)
////			itsSubMorphs = new List<OrdinarySubMorphism>(5, 1);
//		itsSubMorphs.add(aSubMorph);
//		return aSubMorph;
//	}

	/*
	 * Remove a submorphism from my set of submorphisms. *
	 * 
	 * @return <code>false</code> iff <code>sm</code> was not an element of
	 *         my set of submorphisms.*
	 */
//	public final boolean destroySubMorphism(OrdinarySubMorphism sm)
//	{
//		if (itsSubMorphs != null && sm != null) {
//			if (itsSubMorphs.removeElement(sm)) {
//				sm.dispose();
//				return true;
//			}
//		}
//		return false;
//	}

//	private void destroySubMorphisms() {
//		if (itsSubMorphs != null) {
//			while (itsSubMorphs.size() > 0) {
//				OrdinarySubMorphism sm = itsSubMorphs.get(0);
//				itsSubMorphs.remove(sm);
//				sm.dispose();
//			}
//		}
//	}

	/*
	 * Return an Iterator of all of my submorphisms (not including myself).
	 * Iterator elements are of type <code>OrdinarySubMorphism</code>.*
	*/
//	public final Iterator<OrdinarySubMorphism> getSubMorphisms()	{
//		if (itsSubMorphs != null)
//			return itsSubMorphs.elements();
//		else
//			return (new List<OrdinarySubMorphism>(0)).elements();
//	}

	// ----------- ADDITIONAL METHODS according to Gabi's new AGG design
	// --------------
	// -------------------- attention: yet untested! (Aug.1999)
	// -----------------------

	/** swop domain and range <--->, if possible */
	public OrdinaryMorphism invert() {
        if (!(this.isInjective())) {
            this.errorMsg = "Inverting of non-injective morphism is not possible.";
            return (null);
        }
        final OrdinaryMorphism inv = (BaseFactory.theFactory()).createMorphism(this.itsImag, this.itsOrig);
        final Iterator<GraphObject> domain = this.itsDomObjects.iterator();
        while (domain.hasNext()) {
            final GraphObject go = domain.next();
            try {
                inv.addMapping(this.getImage(go), go);
            } catch (BadMappingException e) {
                this.errorMsg = e.getMessage();
            }
        }
        return (inv);
    }

    public OrdinaryMorphism simplecopy() /**
     * *************************************************************************
     * Unlike "morphcopy(.)" of above, "simplecopy()" * does only return a copy of itself without creating copies of its
     * source and target graphs.* ************************************************************************
     */
    {
        final OrdinaryMorphism output = (BaseFactory.theFactory()).createMorphism(
                this.itsOrig, this.itsImag);
        final Iterator<GraphObject> mappedObjects = this.itsDomObjects.iterator();
        while (mappedObjects.hasNext()) {
            final GraphObject go = mappedObjects.next();
            try {
                output.addMapping(go, this.getImage(go));
            } catch (BadMappingException ex) {
            }
        }
        return (output);
    }

    public boolean isIsomorphicTo(final OrdinaryMorphism h) /*
	 * Test if morphism h is isomorphic to this morphism. 
     */ {
        final Iterator<GraphObject> dom = this.getDomain();
        final List<GraphObject> hDom = new ArrayList<>();
        final Iterator<GraphObject> hd = h.getDomain();

        while (hd.hasNext()) {
            hDom.add(hd.next());
        }
        while (dom.hasNext()) {
            final GraphObject go = dom.next();
            if (hDom.contains(go)) {
                if (!this.getImage(go).equals(h.getImage(go))) {
                    hDom.clear();
                    return false;
                }
                hDom.remove(go);

            } else {
                hDom.clear();
                return false;
            }
        }
        if (hDom.size() == 0) {
            return true;
        }
        return false;
    }

    public boolean isIsomorphicTo(final OrdinaryMorphism h, final OrdinaryMorphism targetIso) /**
     * Test if the specified morphism h is isomorphic to this morphism, assuming that : - this and h are total, - this
     * and h have one and the same original graph, - the target graph of this is the source graph of targetIso, - the
     * target graph of h is the target graph of targetIso, - targetIso is an isomorphism.
     */
    {
        // System.out.println("OrdinaryMorphism.isIsomorphicTo(h, targetIso)
        // ...");
        if (this.getSource() != h.getSource()) {
            System.out
                    .println("OrdinaryMorphism.isIsomorphicTo:: FAILED:: this and h have different source graphs");
//			Thread.dumpStack();
            return false;
        } else if (h.getTarget() != targetIso.getTarget()) {
            System.out
                    .println("OrdinaryMorphism.isIsomorphicTo:: FAILED:: targetIso and h have different target graphs");
//			Thread.dumpStack();
            return false;
        }

        final Iterator<Node> e = this.getSource().getNodesSet().iterator();
        while (e.hasNext()) {
            GraphObject o = e.next();
            GraphObject i1 = targetIso.getImage(this.getImage(o));
            GraphObject i2 = h.getImage(o);
            if (i1 != i2) {
                return false;
            }
        }
        final Iterator<Arc> e1 = this.getSource().getArcsSet().iterator();
        while (e1.hasNext()) {
            GraphObject o = e1.next();
            GraphObject i1 = targetIso.getImage(this.getImage(o));
            GraphObject i2 = h.getImage(o);
            if (i1 != i2) {
                return false;
            }
        }
        // System.out.println("OrdinaryMorphism.isIsomorphicTo .... TRUE ");
        return true;
    }

    /**
     * Return <code>true</code> if this is a partial morphism.
     */
    public boolean isPartial() {
        return !isTotal();
    }

    /**
     * Test if this morphism is partial isomorphic to the specified morphism h, assuming that they have one and the same
     * original and one and the same image graph.
     */
    public boolean isPartialIsomorphicTo(final OrdinaryMorphism h) {
        final Iterator<GraphObject> dom = this.getDomain();
        final List<GraphObject> hDomain = h.getDomainObjects();
        while (dom.hasNext()) {
            final GraphObject go = dom.next();
            if (hDomain.contains(go)) {
                if (!this.getImage(go).equals(h.getImage(go))) {
                    return (false);
                } else if (go.isArc()) {
                    if (!this.getImage(((Arc) go).getSource()).equals(h.getImage(((Arc) go).getSource()))
                            || !this.getImage(((Arc) go).getTarget()).equals(h.getImage(((Arc) go).getTarget()))) {
                        return (false);
                    }
                }
            }
//			else
//				return (false);
        }
        return (true);
    }

    public boolean isSurjective() {
        final Iterator<GraphObject> nonMapped = nonMappedImages();
        if (nonMapped.hasNext()) {
            return (false);
        }

        return (true);
    }

    public boolean isInjective() {
        for (int i = 0; i < this.itsCodomObjects.size(); i++) {
            final GraphObject go = this.itsCodomObjects.get(i);
            if (this.getInverseImageList(go).size() > 1) {
                return false;
            }
        }
        return true;
    }

    public boolean isBijective() {
        if (isInjective() && isSurjective()) {
            return (true);
        }

        return (false);
    }

    public Iterator<GraphObject> nonMappedOriginals() /**
     * *************************************************************************
     * Returns all graph objects of the original graph * that are not mapped by this morphism. Iterator * elements are
     * of type <code>GraphObject</code>.
     *
     * @see agg.xt_basis.GraphObject.* ************************************************************************
     */
    {
        final List<GraphObject> nonMapped = new ArrayList<>();

        final Iterator<Node> nodes = this.itsOrig.getNodesSet().iterator();
        while (nodes.hasNext()) {
            GraphObject go = nodes.next();
            if (!this.itsDomObjects.contains(go)) {
                nonMapped.add(go);
            }
        }
        final Iterator<Arc> arcs = this.itsOrig.getArcsSet().iterator();
        while (arcs.hasNext()) {
            GraphObject go = arcs.next();
            if (!this.itsDomObjects.contains(go)) {
                nonMapped.add(go);
            }
        }
        return nonMapped.iterator();
    }

    public Iterator<GraphObject> nonMappedImages() /**
     * *************************************************************************
     * Returns all graph objects of the image graph * that are not used by this morphism. Iterator * elements are of
     * type <code>GraphObject</code>.
     *
     * @see agg.xt_basis.GraphObject * ************************************************************************
     */
    {
        final List<GraphObject> nonMapped = new ArrayList<>();
        final Iterator<Node> gos = this.itsImag.getNodesSet().iterator();
        while (gos.hasNext()) {
            GraphObject go = gos.next();
            if (!this.itsCodomObjects.contains(go)) {
                nonMapped.add(go);
            }
        }
        final Iterator<Arc> gos1 = this.itsImag.getArcsSet().iterator();
        while (gos1.hasNext()) {
            GraphObject go = gos1.next();
            if (!this.itsCodomObjects.contains(go)) {
                nonMapped.add(go);
            }
        }
        return (nonMapped.iterator());
    }

    /**
     * Constructs the composition of this morphism and the input morphism.<br>
     * this.source == output.source, <br>
     * this.target == input.source, <br>
     * input.target == output.target.<br>
     * .
     */
    public OrdinaryMorphism compose(final OrdinaryMorphism input) {
        final OrdinaryMorphism output = (BaseFactory.theFactory()).createMorphism(
                this.itsOrig, input.getImage(), true);
        final Iterator<GraphObject> thisDom = this.itsDomObjects.iterator();
        while (thisDom.hasNext()) {
            final GraphObject thisGo = thisDom.next();
            final GraphObject thisGoImage = this.getImage(thisGo);
            final GraphObject inputGoImage = input.getImage(thisGoImage);
            if (inputGoImage != null) {
                try {
                    output.addMapping(thisGo, inputGoImage);
                } catch (BadMappingException ex) {
                }
            }
        }
        return (output);
    }

    /**
     * Constructs composition of given morphisms morph1 and morph2 morphisms, where <br>
     * this.source == morph1.source <br>
     * this.target == morph2.target <br>
     * morph1.target == morph2.source. <br>
     * Returns true, if the source-target condition is satisfied, otherwise - false.
     */
    public boolean doCompose(final OrdinaryMorphism morph1, final OrdinaryMorphism morph2) {
        if (this.itsOrig == morph1.getSource()
                && this.itsImag == morph2.getTarget()) {
            final Iterator<GraphObject> dom = morph1.getDomain();
            while (dom.hasNext()) {
                final GraphObject obj = dom.next();
                final GraphObject im = morph1.getImage(obj);
                final GraphObject img = morph2.getImage(im);
                if (img != null) {
                    try {
                        this.addMapping(obj, img);
                    } catch (BadMappingException ex) {
                        System.out.println(ex.getClass() + "   " + ex.getMessage());
                        return false;
                    }
                }
            }
            return true;
        }
        return false;
    }

    public boolean doComposeInherit(final OrdinaryMorphism morph1, final OrdinaryMorphism morph2) {
        if (this.itsOrig == morph1.getSource()
                && this.itsImag == morph2.getTarget()) {
            final Iterator<GraphObject> dom = morph1.getDomain();
            while (dom.hasNext()) {
                final GraphObject obj = dom.next();
                final GraphObject img1 = morph1.getImage(obj);
                final GraphObject img2 = morph2.getImage(img1);
                if (img2 != null) {
                    try {
                        if (obj.getType().isParentOf(img2.getType())) {
                            this.addMapping(obj, img2);
                        } else if (obj.getType().isChildOf(img2.getType())) {
                            this.addChild2ParentMapping(obj, img2);
                        }
                    } catch (BadMappingException ex) {
                        return false;
                    }
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Given an input morphism with input.getSource() == this.getSource() and <br>
     * input.getTarget() == output.getSource() and <br>
     * this.getTarget() == output.getTarget(). <br>
     * For each key try to complete output.addMapping(input.get(key), this.getImage(key)).<br>
     * Returns true by success, otherwise true.
     */
    public OrdinaryMorphism completeDiagram(final OrdinaryMorphism input) {
        if (!input.isInjective()) {
            this.errorMsg = "Completting with non-injective morphism is not possible";
            return (null);
        }
        final OrdinaryMorphism compl = (BaseFactory.theFactory()).createMorphism(
                input.getImage(), this.itsImag);
        final Iterator<GraphObject> inpDom = input.getDomain();
        while (inpDom.hasNext()) {
            final GraphObject inpGo = inpDom.next();
            final GraphObject inpImg = input.getImage(inpGo);
            final GraphObject thisImgGo = this.getImage(inpGo);
            try {
                compl.addMapping(inpImg, thisImgGo);
            } catch (BadMappingException ex) {
                (BaseFactory.theFactory()).destroyMorphism(compl);
                return null;
            }
        }
        return (compl);
    }

    /**
     * Given d = g o f with f: A->B, g: B->C, d: A->C. f and d is known, g is this. Try to complete g. Returns true by
     * success, otherwise false.
     */
    public boolean completeDiagram(final Hashtable<GraphObject, GraphObject> f,
            final OrdinaryMorphism d) {
        if (f != null && d != null) {
            Iterator<GraphObject> dDom = d.getDomain();
            while (dDom.hasNext()) {
                final GraphObject go3 = dDom.next();
                final GraphObject img3 = d.getImage(go3);
                final GraphObject img1 = f.get(go3);
                if (img1 != null && img3 != null) {
                    try {
                        this.addMapping(img1, img3);
                    } catch (BadMappingException ex) {
                        this.clear();
                        this.errorMsg = "Complete of diagram: d = g o f is not possible (object mapping failed)";
                        return false;
                    }
                }
            }
            return true;
        } else {
            this.errorMsg = "Complete of diagram: d = g o f is not possible (d resp. f is null)";
            return false;
        }
    }

    /**
     * We have a diagram third = first o second with first: A->B, second: B->C, third: A->C,<br>
     * second and third are complete.<br>
     * Try to complete first. Note, first morphism is this morphism. Returns true by success, otherwise false.
     */
    public boolean completeDiagram1(
            final OrdinaryMorphism second,
            final OrdinaryMorphism third) {
        if (second != null && third != null) {
//			AttrContext context = agg.attribute.impl.AttrTupleManager
//						.getDefaultManager().newContext(AttrMapping.PLAIN_MAP);
//			this.setAttrContext(context);

            final Iterator<GraphObject> dom = second.getDomain();
            while (dom.hasNext()) {
                GraphObject go2 = dom.next();
                GraphObject img2 = second.getImage(go2);
                Iterator<GraphObject> en = third.getInverseImage(img2);
                if (en.hasNext()) {
                    GraphObject go1 = en.next();
                    try {
                        this.addMapping(go1, go2);
                    } catch (BadMappingException ex) {
                        this.clear();
                        this.errorMsg = "Complete of diagram1 is not possible (object mapping failed)";
                        return false;
                    }
                }
            }
            return true;
        } else {
            this.errorMsg = "Complete of diagram1 is not possible (second or third is null)";
            return false;
        }
    }

    /**
     * We have a diagram third = first o second with first: A->B, second: B->C, third: A->C,<br>
     * first and third are complete.<br>
     * Try to complete second. Note, second morphism is this morphism. Returns true by success, otherwise false.
     */
    public boolean completeDiagram2(
            final OrdinaryMorphism first,
            final OrdinaryMorphism third) {
        if (first != null && third != null) {
            if (!first.isInjective()) {
                this.errorMsg = "Complete of diagram2 is not possible (first is non-injective)";
                return false;
            } else {
//				AttrContext context = agg.attribute.impl.AttrTupleManager
//						.getDefaultManager().newContext(AttrMapping.PLAIN_MAP);
//				this.setAttrContext(context);

                final Iterator<GraphObject> dom = first.getDomain();
                while (dom.hasNext()) {
                    GraphObject go1 = dom.next();
                    GraphObject img1 = first.getImage(go1);
                    GraphObject img3 = third.getImage(go1);
                    if (img3 != null) {
                        try {
                            this.addMapping(img1, img3);
                        } catch (BadMappingException ex) {
                            this.clear();
                            this.errorMsg = "Complete of diagram2 is not possible (object mapping failed)";
                            return false;
                        }
                    }
                }
                return true;
            }
        } else {
            this.errorMsg = "Complete of diagram2 is not possible (first resp. third is null)";
            return false;
        }
    }

    /**
     * We have a diagram third = first o second with first: A->B, second: B->C, third: A->C,<br>
     * first and second are complete.<br>
     * Try to complete third. Note, third morphism is this morphism. Returns true by success, otherwise false.
     */
    public boolean completeDiagram3(
            final OrdinaryMorphism first,
            final OrdinaryMorphism second) {
        if (first != null && second != null) {
            if (!first.isInjective()) {
                this.errorMsg = "Complete of diagram3 is not possible (first is non-injective)";
                return false;
            } else {
//				AttrContext context = agg.attribute.impl.AttrTupleManager
//						.getDefaultManager().newContext(AttrMapping.PLAIN_MAP);
//				this.setAttrContext(context);

                final Iterator<GraphObject> dom = first.getDomain();
                while (dom.hasNext()) {
                    GraphObject go1 = dom.next();
                    GraphObject img2 = second.getImage(first.getImage(go1));
                    if (img2 != null) {
                        try {
                            this.addMapping(go1, img2);
                        } catch (BadMappingException ex) {
                            this.clear();
                            this.errorMsg = "Complete of diagram3 is not possible (object mapping failed)";
                            return false;
                        }
                    }
                }
                return true;
            }
        } else {
            this.errorMsg = "Complete of diagram3 is not possible (first resp. second is null)";
            return false;
        }
    }

    /**
     * Given this = d = g o f with f: A->B, g: B->C, d: A->C. d and f are complete. Try to complete g. Returns true by
     * success, otherwise false.
     */
    public boolean completeDiagram(
            final OrdinaryMorphism f,
            final OrdinaryMorphism g) {
        if (f != null && g != null) {
            if (!f.isInjective()) {
                this.errorMsg = "Complete of diagram: d = g o f is not possible (f is non-injective)";
                return false;
            } else {
                AttrContext context = agg.attribute.impl.AttrTupleManager
                        .getDefaultManager().newContext(AttrMapping.PLAIN_MAP);
                g.setAttrContext(context);

                final Iterator<GraphObject> fDom = f.getDomain();
                while (fDom.hasNext()) {
                    final GraphObject fGO = fDom.next();
                    final GraphObject img1 = f.getImage(fGO);
                    final GraphObject img2 = this.getImage(fGO);
                    if (img1 != null && img2 != null) {
                        try {
                            g.addMapping(img1, img2);
                        } catch (BadMappingException ex) {
                            g.clear();
                            this.errorMsg = "Complete of diagram: d = g o f is not possible (object mapping failed)";
                            return false;
                        }
                    }
                }
                return true;
            }
        } else {
            this.errorMsg = "Complete of diagram: d = g o f is not possible (g resp. f is null)";
            return false;
        }
    }

    /**
     * The given morphisms h1, v2, v1 are already complete. Try to complete this morphism : C -> D so that v2 o h1 = h2
     * o v1 .
     *
     * @param v1 : A -> C
     * @param h1 : A -> B
     * @param v2 : B -> D
     *
     * @return true if morphism this morphism : C -> D completed, otherwise false
     */
    public boolean completeDiagram(final OrdinaryMorphism v1,
            final OrdinaryMorphism h1,
            final OrdinaryMorphism v2) {
        boolean ok = true;
        final Iterator<GraphObject> dom = h1.getDomain();
        while (dom.hasNext() && ok) {
            GraphObject obj = dom.next();
            GraphObject obj1 = v1.getImage(obj);
            GraphObject obj2 = v2.getImage(h1.getImage(obj));
            if (obj1 != null && obj2 != null) {
                try {
                    this.addMapping(obj1, obj2);
                } catch (BadMappingException ex) {
                    ok = false;
                }
            }
        }
        return ok;
    }

    public Iterator<GraphObject> intersectCoDomains(final OrdinaryMorphism input) /**
     * *************************************************************************
     * Return all graph objects of current codomain that reside * in the codomain of the input morphism, too. Iterator *
     * elements are of type <code>GraphObject</code>.
     *
     * @see agg.xt_basis.GraphObject * ************************************************************************
     */
    {
        final List<GraphObject> intersection = new ArrayList<>();
        final Iterator<GraphObject> inpCodom = input.getCodomain();

        while (inpCodom.hasNext()) {
            final GraphObject g = inpCodom.next();
            if (this.itsCodomObjects.contains(g)) {
                intersection.add(g);
            }
        }
        return (intersection.iterator());
    }

    /**
     * Check if the constant value of the same attribute member of the original and image graph objects are equal.
     */
    public boolean checkConstants() {
        if (this.itsDomObjects.isEmpty()) {
            return true;
        }

        for (int j = 0; j < this.itsDomObjects.size(); j++) {
            final GraphObject orig = this.itsDomObjects.get(j);
            if (orig.getAttribute() == null) {
                continue;
            }

            final GraphObject image = getImage(orig);
            final ValueTuple valOrig = (ValueTuple) orig.getAttribute();
            final ValueTuple valImage = (ValueTuple) image.getAttribute();
            int n = valOrig.getNumberOfEntries();
            for (int i = 0; i < n; i++) {
                final String name = valOrig.getNameAsString(i);
                ValueMember valMemberOrig = null;
                if (valOrig.isValueSetAt(name)) {
                    valMemberOrig = valOrig.getValueMemberAt(name);
                    final HandlerExpr exprOrig = valMemberOrig.getExpr();
                    if ((exprOrig != null) && exprOrig.isConstant()) {
                        if (valImage.isValueSetAt(name)) {
                            final ValueMember valMemberImage = valImage
                                    .getValueMemberAt(name);
                            final HandlerExpr exprImage = valMemberImage.getExpr();
                            if ((exprImage != null) && exprImage.isConstant()) {
                                if (!valMemberOrig.toString().equals(
                                        valMemberImage.toString())) {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
        }
        return true;
    }

    /**
     * Check if the variable of the same attribute member of the original and image graph objects are equal.
     */
    public boolean checkVariables() {
        if (this.itsDomObjects.isEmpty()) {
            return true;
        }

        for (int j = 0; j < this.itsDomObjects.size(); j++) {
            final GraphObject orig = this.itsDomObjects.get(j);
            if (orig.getAttribute() == null) {
                continue;
            }

            final GraphObject image = getImage(orig);
            final ValueTuple valOrig = (ValueTuple) orig.getAttribute();
            final ValueTuple valImage = (ValueTuple) image.getAttribute();
            int n = valOrig.getNumberOfEntries();
            for (int i = 0; i < n; i++) {
                final String name = valOrig.getNameAsString(i);
                ValueMember valMemberOrig = null;
                if (valOrig.isValueSetAt(name)) {
                    valMemberOrig = valOrig.getValueMemberAt(name);
                    final HandlerExpr exprOrig = valMemberOrig.getExpr();
                    if ((exprOrig != null) && exprOrig.isVariable()) {
                        if (valImage.isValueSetAt(name)) {
                            final ValueMember valMemberImage = valImage
                                    .getValueMemberAt(name);
                            final HandlerExpr exprImage = valMemberImage.getExpr();
                            if ((exprImage != null) && exprImage.isVariable()) {
                                if (!valMemberOrig.toString().equals(
                                        valMemberImage.toString())) {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
        }
        return true;
    }

    /**
     * Check if the setting of the same attribute member of the original and image graph objects are equal.
     */
    protected boolean checkAll() {
        if (this.itsDomObjects.isEmpty()) {
            return true;
        }
        for (int j = 0; j < this.itsDomObjects.size(); j++) {
            final GraphObject orig = this.itsDomObjects.get(j);
            if (orig.getAttribute() == null) {
                continue;
            }

            final GraphObject image = getImage(orig);
            final ValueTuple valOrig = (ValueTuple) orig.getAttribute();
            final ValueTuple valImage = (ValueTuple) image.getAttribute();
            int n = valOrig.getNumberOfEntries();
            for (int i = 0; i < n; i++) {
                final String name = valOrig.getNameAsString(i);
                ValueMember valMemberOrig = null;
                if (valOrig.isValueSetAt(name)) {
                    valMemberOrig = valOrig.getValueMemberAt(name);
                    if ((valMemberOrig.isSet())) {
                        if (valImage.isValueSetAt(name)) {
                            final ValueMember valMemberImage = valImage
                                    .getValueMemberAt(name);
                            if (valMemberImage != null && valMemberImage.isSet()) {
                                if (!valMemberOrig.getExprAsText().equals(
                                        valMemberImage.getExprAsText())) {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
        }
        return true;
    }

    public void putVarToAttrContext() {
        final VarTuple vars = (VarTuple) getAttrContext().getVariables();

        putVarToAttrContext(this.itsOrig.getNodesSet().iterator(), vars);
        putVarToAttrContext(this.itsOrig.getArcsSet().iterator(), vars);

        putVarToAttrContext(this.itsImag.getNodesSet().iterator(), vars);
        putVarToAttrContext(this.itsImag.getArcsSet().iterator(), vars);
    }

    private void putVarToAttrContext(
            final Iterator<?> elems,
            final VarTuple vars) {

        while (elems.hasNext()) {
            final GraphObject o = (GraphObject) elems.next();
            if (o.getAttribute() == null) {
                continue;
            }

            final ValueTuple val = (ValueTuple) o.getAttribute();
            int n = val.getNumberOfEntries();
            for (int i = 0; i < n; i++) {
                final String name = val.getNameAsString(i);
                final ValueMember valMem = val.getValueMemberAt(name);
                if (valMem != null && valMem.isSet()) {
                    if (valMem.getExpr().isVariable()) {
                        final String varName = valMem.getExprAsText();
                        if (vars.getVarMemberAt(varName) == null) {
                            final String varType = valMem.getDeclaration()
                                    .getTypeName();
                            vars.declare(valMem.getDeclaration().getHandler(),
                                    varType, varName);
                        }
                    }
                }
            }
        }
    }

    /**
     * If the value of an attribute member of the original graphobject is unset or is a variable, fill up such attribute
     * value with the value (it should be a constant value) of the same attribute member of the image graphobject.
     */
    public void fillUpOriginalAttrs() {
        final Iterator<GraphObject> elems = this.itsDomObjects.iterator();
        while (elems.hasNext()) {
            final GraphObject orig = elems.next();
            final GraphObject image = getImage(orig);
            if (orig.getAttribute() != null) {
                final ValueTuple valOrig = (ValueTuple) orig.getAttribute();
                final ValueTuple valImage = (ValueTuple) image.getAttribute();
                int n = valOrig.getNumberOfEntries();
                for (int i = 0; i < n; i++) {
                    final String name = valOrig.getNameAsString(i);
                    ValueMember valMemberOrig = null;
                    HandlerExpr exprOrig = null;
                    if (valOrig.isValueSetAt(name)) {
                        valMemberOrig = valOrig.getValueMemberAt(name);
                        exprOrig = valMemberOrig.getExpr();
                    }
                    if ((exprOrig == null) || !exprOrig.isConstant()) {
                        if (valImage.isValueSetAt(name)) {
                            ValueMember valMemberImage = valImage
                                    .getValueMemberAt(name);
                            HandlerExpr exprImage = valMemberImage.getExpr();
                            if ((exprImage != null) && exprImage.isConstant()) {
                                valOrig.setExprValueAt(valMemberImage
                                        .getExprAsText(), name);
                                (valOrig.getValueMemberAt(name))
                                        .setTransient(true);
                                valOrig.getValueMemberAt(name).checkValidity();
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Iff the value of an attribute member of the image graphobject is unset or is a variable, fill up the value of
     * such attribute member with the value (it should be a constant value) of the same attribute member of the original
     * graphobject.
     */
    public void fillUpImageAttrs() {
        final Iterator<GraphObject> elems = this.itsDomObjects.iterator();
        while (elems.hasNext()) {
            final GraphObject orig = elems.next();
            final GraphObject image = getImage(orig);
            if (orig.getAttribute() != null) {
                final ValueTuple valOrig = (ValueTuple) orig.getAttribute();
                final ValueTuple valImage = (ValueTuple) image.getAttribute();
                int n = valImage.getNumberOfEntries();
                for (int i = 0; i < n; i++) {
                    final String name = valImage.getNameAsString(i);
                    ValueMember valMemberImage = null;
                    HandlerExpr exprImage = null;
                    if (valImage.isValueSetAt(name)) {
                        valMemberImage = valImage.getValueMemberAt(name);
                        exprImage = valMemberImage.getExpr();
                    }
                    if ((exprImage == null) || !exprImage.isConstant()) {
                        if (valOrig.isValueSetAt(name)) {
                            final ValueMember valMemberOrig = valOrig
                                    .getValueMemberAt(name);
                            final HandlerExpr exprOrig = valMemberOrig.getExpr();
                            if ((exprOrig != null) && exprOrig.isConstant()) {
                                valImage.setExprValueAt(valMemberOrig
                                        .getExprAsText(), name);
                                (valImage.getValueMemberAt(name))
                                        .setTransient(true);
                                valImage.getValueMemberAt(name).checkValidity();
                            }
                        }
                    }
                }
            }
        }
    }

    private List<GraphObject> findCreatedElements() {
        final List<GraphObject> vec = new ArrayList<>();
        for (Iterator<Node> en = this.itsImag.getNodesSet().iterator(); en.hasNext();) {
            final GraphObject o = en.next();
            if (!getInverseImage(o).hasNext()) {
                vec.add(o);
            }
        }
        for (Iterator<Arc> en = this.itsImag.getArcsSet().iterator(); en.hasNext();) {
            final GraphObject o = en.next();
            if (!getInverseImage(o).hasNext()) {
                vec.add(o);
            }
        }
        return vec;
    }

    private List<GraphObject> findDeletedElements() {
        final List<GraphObject> vec = new ArrayList<>();
        for (Iterator<Node> en = this.itsOrig.getNodesSet().iterator(); en.hasNext();) {
            final GraphObject o = en.next();
            if (getImage(o) == null) {
                vec.add(o);
            }
        }
        for (Iterator<Arc> en = this.itsOrig.getArcsSet().iterator(); en.hasNext();) {
            final GraphObject o = en.next();
            if (getImage(o) == null) {
                vec.add(o);
            }
        }
        return vec;
    }

    /**
     * Iff the value of an attribute member of the original graphobject is an expression, unset it.
     */
    public void unsetOriginalAttrsIfExpression() {
        final Iterator<Node> elems = this.itsOrig.getNodesSet().iterator();
        while (elems.hasNext()) {
            GraphObject orig = elems.next();
            if (orig.getAttribute() == null) {
                continue;
            }
            ValueTuple valOrig = (ValueTuple) orig.getAttribute();
            int n = valOrig.getNumberOfEntries();
            for (int i = 0; i < n; i++) {
                String name = valOrig.getNameAsString(i);
                ValueMember valMemberOrig = null;
                HandlerExpr exprOrig = null;
                if (valOrig.isValueSetAt(name)) {
                    valMemberOrig = valOrig.getValueMemberAt(name);
                    if (valMemberOrig != null) {
                        exprOrig = valMemberOrig.getExpr();
                        if ((exprOrig != null) && exprOrig.isComplex()) {
                            valMemberOrig.setExpr(null);
                        }
                    }
                }
            }
        }
        final Iterator<Arc> elems1 = this.itsOrig.getArcsSet().iterator();
        while (elems1.hasNext()) {
            GraphObject orig = elems1.next();
            if (orig.getAttribute() == null) {
                continue;
            }
            ValueTuple valOrig = (ValueTuple) orig.getAttribute();
            int n = valOrig.getNumberOfEntries();
            for (int i = 0; i < n; i++) {
                String name = valOrig.getNameAsString(i);
                ValueMember valMemberOrig = null;
                HandlerExpr exprOrig = null;
                if (valOrig.isValueSetAt(name)) {
                    valMemberOrig = valOrig.getValueMemberAt(name);
                    if (valMemberOrig != null) {
                        exprOrig = valMemberOrig.getExpr();
                        if ((exprOrig != null) && exprOrig.isComplex()) {
                            valMemberOrig.setExpr(null);
                        }
                    }
                }
            }
        }
    }

    public void fillUpAttrContext(final AttrContext other) {
        if ((other == null) || (this.getAttrContext() == null)) {
            return;
        }
        // System.out.println(">>>
        // OrdinaryMorphism.fillUpAttrContext(AttrContext other) ");
        final VarTuple avt = (VarTuple) this.getAttrContext().getVariables();
        final VarTuple avtOther = (VarTuple) other.getVariables();
        // System.out.println("--> "+avt+" "+avtOther);

        // gehe <other> Attrcontext durch und stelle fest
        // ob er schon in <this> attrcontext vorhandene Variablen
        // mit einem Wert als Konstante hat oder
        // eine neue Variable mit einem konstanten Wert,
        // und ersetze oder hinzufuege diese Variable.
        int nn = avtOther.getNumberOfEntries();
        for (int i = 0; i < nn; i++) {
            final VarMember avmOther = avtOther.getVarMemberAt(i);
            final String name = avtOther.getNameAsString(i);
            final VarMember avm = avt.getVarMemberAt(name);

            // System.out.println(name+" "+avm+" "+avmOther);
            if (avm != null) {
                // if(avmOther.isInputParameter())
                {
                    // setze den Wert
                    if (avmOther.isSet() && avmOther.getExpr().isConstant()) {
                        avm.setExprAsText(avmOther.getExprAsText());
                        // System.out.println(name+" "+avm+"\nas copy of:
                        // "+avmOther);
                    }
                }
            }
        }
    }

    public void copyAttrContext(final AttrContext other) {
        if ((other == null) || (this.getAttrContext() == null)) {
            return;
        }

        final VarTuple avt = (VarTuple) this.itsAttrContext.getVariables();
        final VarTuple avtOther = (VarTuple) other.getVariables();
        int nn = avtOther.getNumberOfEntries();

        for (int i = 0; i < nn; i++) {
            final VarMember avmOther = avtOther.getVarMemberAt(i);
            final String name = avtOther.getNameAsString(i);
            final VarMember avm = avt.getVarMemberAt(name);

            // System.out.println(name+" "+avm+" "+avmOther);
            if (avm != null) {
                // ersetze den Wert von der Variablen
                if (avmOther.isSet() && avmOther.getExpr().isConstant()) {
                    avm.setExprAsText(avmOther.getExprAsText());
                    // System.out.println(name+" "+avm+"\nas copy of:
                    // "+avmOther);
                }
                if (avmOther.isInputParameter()) {
                    avm.setInputParameter(true);
                }
            } // fuege eine neue Variable mit/ohne einem Wert hinzu
            else {
                // System.out.println("add new member");
                final DeclMember dm = (DeclMember) avmOther.getDeclaration();

                avt.declare(dm.getHandler(), dm.getTypeName(), dm.getName());
                final ValueMember newMember = avt.getVarMemberAt(dm.getName());

                if ((newMember != null) && (avmOther.getExpr() != null)
                        && avmOther.getExpr().isConstant()) {
                    newMember.setExprAsText(avmOther.getExprAsText());
                    // System.out.println(name+" "+avm+"\nas copy of:
                    // "+avmOther);
                }

                (avt.getVarMemberAt(dm.getName())).setInputParameter(avmOther
                        .isInputParameter());

                (avt.getVarMemberAt(dm.getName())).setTransient(avmOther
                        .isTransient());
                // System.out.println(name+" "+newMember+"\nas copy of:
                // "+avmOther);
            }
        }
    }

    /*
	 * Returns a hashtable where the key is an input parameter and the object is
	 * a List of pairs. The first pair element is an attribute member and the
	 * second pair element is appropriate graphobject type.
     */
    public Hashtable<VarMember, List<Pair<ValueMember, Type>>> getUsageOfInputParameters(
            final AttrContext attrContext) {
        // AttrContext attrContext = getAttrContext();
        final Hashtable<VarMember, List<Pair<ValueMember, Type>>> ht = new Hashtable<VarMember, List<Pair<ValueMember, Type>>>();

//		if (this instanceof SubRule) {
        // System.out.println("OrdinaryMorphism.getUsageOfInputParameters :
        // this instance of SubRule");
        // attrContext = ((SubRule) this).getSuperRule().getAttrContext();
//		}
        if (attrContext == null || attrContext.getVariables() == null) {
            return ht;
        }

        final List<Type> tmp = new ArrayList<>();
        final VarTuple avt = (VarTuple) attrContext.getVariables();
        for (int i = 0; i < avt.getSize(); i++) {
            final VarMember avm = avt.getVarMemberAt(i);
            if (avm.getExpr() == null) {
                return ht;
            }
            // System.out.println(avm+" "+avm.getExpr());
            // System.out.println(avm.getDeclaration().getName());

            final List<Pair<ValueMember, Type>> v = new ArrayList<>();
            if (avm.isInputParameter()) {
                // System.out.println("search source graph");
                final Iterator<Node> en = getSource().getNodesSet().iterator();
                while (en.hasNext()) {
                    GraphObject go = en.next();
                    if (go.getAttribute() == null) {
                        continue;
                    }
                    final ValueTuple vt = (ValueTuple) go.getAttribute();
                    for (int j = 0; j < vt.getSize(); j++) {
                        final ValueMember vm = vt.getValueMemberAt(j);
                        if ((vm.getExpr() != null) && vm.getExpr().isVariable()) {
                            // System.out.println("value member:
                            // "+vm.getExprAsText());
                            // System.out.println("input param :
                            // "+avm.getDeclaration().getName());
                            if (vm.getExprAsText().equals(
                                    avm.getDeclaration().getName())) {
                                v.add(new Pair<ValueMember, Type>(vm, go
                                        .getType()));
                                tmp.add(go.getType());
                            }
                        }
                    }
                }
                final Iterator<Arc> en1 = getSource().getArcsSet().iterator();
                while (en1.hasNext()) {
                    final GraphObject go = en1.next();
                    if (go.getAttribute() == null) {
                        continue;
                    }
                    final ValueTuple vt = (ValueTuple) go.getAttribute();
                    for (int j = 0; j < vt.getSize(); j++) {
                        final ValueMember vm = vt.getValueMemberAt(j);
                        if ((vm.getExpr() != null) && vm.getExpr().isVariable()) {
                            // System.out.println("value member:
                            // "+vm.getExprAsText());
                            // System.out.println("input param :
                            // "+avm.getDeclaration().getName());
                            if (vm.getExprAsText().equals(
                                    avm.getDeclaration().getName())) {
                                v.add(new Pair<ValueMember, Type>(vm, go
                                        .getType()));
                                tmp.add(go.getType());
                            }
                        }
                    }
                }
                // System.out.println("search target graph");
                final Iterator<Node> en2 = getTarget().getNodesSet().iterator();
                while (en2.hasNext()) {
                    final GraphObject go = en2.next();
                    if (go.getAttribute() == null) {
                        continue;
                    }
                    final ValueTuple vt = (ValueTuple) go.getAttribute();
                    for (int j = 0; j < vt.getSize(); j++) {
                        final ValueMember vm = vt.getValueMemberAt(j);
                        if ((vm.getExpr() != null) && vm.getExpr().isVariable()) {
                            // System.out.println("value member:
                            // "+vm.getExprAsText());
                            // System.out.println("input param :
                            // "+avm.getDeclaration().getName());
                            if (vm.getExprAsText().equals(
                                    avm.getDeclaration().getName())) {
                                // System.out.println(" will be used!");
                                if (tmp.isEmpty()
                                        || !tmp.contains(go.getType())) {
                                    v.add(new Pair<ValueMember, Type>(
                                            vm, go.getType()));
                                    tmp.add(go.getType());
                                }
                            }
                        }
                    }
                }
                final Iterator<Arc> en3 = getTarget().getArcsSet().iterator();
                while (en3.hasNext()) {
                    final GraphObject go = en3.next();
                    if (go.getAttribute() == null) {
                        continue;
                    }
                    final ValueTuple vt = (ValueTuple) go.getAttribute();
                    for (int j = 0; j < vt.getSize(); j++) {
                        final ValueMember vm = vt.getValueMemberAt(j);
                        if ((vm.getExpr() != null) && vm.getExpr().isVariable()) {
                            // System.out.println("value member:
                            // "+vm.getExprAsText());
                            // System.out.println("input param :
                            // "+avm.getDeclaration().getName());
                            if (vm.getExprAsText().equals(
                                    avm.getDeclaration().getName())) {
                                // System.out.println(" will be used!");
                                if (tmp.isEmpty()
                                        || !tmp.contains(go.getType())) {
                                    v.add(new Pair<ValueMember, Type>(
                                            vm, go.getType()));
                                    tmp.add(go.getType());
                                }
                            }
                        }
                    }
                }
                if (v.size() != 0) {
                    ht.put(avm, v);
                }
            }
        }
        // System.out.println("Count of input parameters: "+ht.size());
        return ht;
    }

    /**
     * Computes an overlapping set of the graphs: - this.source with other.source if other instance of OrdinaryMorphism
     * and left is true, or - this.target with other.target if other instance of OrdinaryMorphism and left is false, or
     * - this.sorce with other if other instance of Graph and left is true, or - this.target with other if other
     * instance of Graph and left is false, or with respect of the rules if this and other are instances of Rule.
     *
     * @param union If true - the overlappings contain disjunion, too. Iterator elements are of type <code>Pair</code>.
     * @return A set of overlappings.
     */
    public Iterator<Pair<OrdinaryMorphism, OrdinaryMorphism>> getOverlappings(
            final Object other, boolean left, boolean union) {
        return MatchHelper.getOverlappingsVector(this, other, left, union).iterator();
    }

    public List<Pair<OrdinaryMorphism, OrdinaryMorphism>> getOverlappingsVector(
            final Object other,
            boolean left,
            boolean union) {
        return MatchHelper.getOverlappingsVector(this, other, left, union);
    }

    /**
     * Computes an overlapping set of the graphs: - this.source with other.source if other instance of OrdinaryMorphism
     * and left is true, or - this.target with other.target if other instance of OrdinaryMorphism and left is false, or
     * - this.sorce with other if other instance of Graph and left is true, or - this.target with other if other
     * instance of Graph and left is false, or with respect of the rules if this and other are instances of Rule.
     *
     * @param sizeOfInclusions The size of graph object inclusions.
     * @param union If true - the overlappings contain disjunion, too. Iterator elements are of type <code>Pair</code>.
     * @return A set of overlappings.
     */
    public Iterator<Pair<OrdinaryMorphism, OrdinaryMorphism>> getOverlappings(
            final Object other, boolean left,
            int sizeOfInclusions, boolean union) {
        return MatchHelper.getOverlappingsVector(this, other, left, sizeOfInclusions, union).iterator();
    }

    public List<Pair<OrdinaryMorphism, OrdinaryMorphism>> getOverlappingsVector(
            final Object otherObj,
            boolean left,
            int sizeOfInclusions,
            boolean union) {
        return MatchHelper.getOverlappingsVector(this, otherObj, left, sizeOfInclusions, union);
    }

    public void setCoMorphism(final OrdinaryMorphism aCoMorph) {
        this.itsCoMorph = aCoMorph;
    }

    public OrdinaryMorphism getCoMorphism() {
        return this.itsCoMorph;
    }

    protected void deleteTransientContextVariables(Graph g) {
        // System.out.println("OrdinaryMorphism.deleteTransientContextVariables()");
        final VarTuple vars = (VarTuple) getAttrContext().getVariables();
        delTransientContextVar(g.getNodesSet().iterator(), vars);
        delTransientContextVar(g.getArcsSet().iterator(), vars);
    }

    private void delTransientContextVar(
            final Iterator<?> elems,
            final VarTuple vars) {

        while (elems.hasNext()) {
            GraphObject obj = (GraphObject) elems.next();
            if (obj.getAttribute() == null) {
                continue;
            }
            ValueTuple value = (ValueTuple) obj.getAttribute();
            for (int i = 0; i < value.getNumberOfEntries(); i++) {
                ValueMember valuem = value.getValueMemberAt(i);
                if (valuem.isTransient()) {
                    // System.out.println(valuem+" "+valuem.getExprAsText());
                    if (!vars.isEmpty()) {
                        vars.getTupleType().deleteMemberAt(valuem.getExprAsText());
                    }
                    valuem.setExpr(null);
                }
            }
        }
    }

    public int getSize() {
        return this.itsDomObjects.size();
    }

    public boolean compareTo(OrdinaryMorphism morph) {
        String errMsgHolder = null;
        if (!getSource().compareTo(morph.getSource())) {
            errMsgHolder = errMsgHolder + "LHS is different";
            return false;
        }
        if (!getTarget().compareTo(morph.getTarget())) {
            errMsgHolder = errMsgHolder + "RHS is different";
            return false;
        }
        // compare mapping
        Iterator<GraphObject> e = morph.getDomain();
        List<GraphObject> another = new ArrayList<>();
        while (e.hasNext()) {
            another.add(e.next());
        }
        if (this.itsDomObjects.size() != another.size()) {
            return false;
        }
        for (int i = 0; i < this.itsDomObjects.size(); i++) {
            GraphObject obj = this.itsDomObjects.get(i);
            GraphObject img = this.getImage(obj);
            for (int j = another.size() - 1; j >= 0; j--) {
                GraphObject obj1 = another.get(j);
                if (obj.compareTo(obj1)) {
                    GraphObject img1 = morph.getImage(obj1);
                    if (img == null && img1 == null) {
                        another.remove(obj1);
                        break;
                    } else if (img != null && img1 == null) {
                    } else if (img == null && img1 != null) {
                    } else if (img != null && img.compareTo(img1)) {
                        another.remove(obj1);
                        break;
                    }
                }
            }
        }
        if (another.size() != 0) {
            errMsgHolder = errMsgHolder + "Morphism mapping is different";
            return false;
        }

        return true;
    }

    /**
     * Returns a List with variable declarations used in LHS and RHS of this graph morphism. An Element of the List is a
     * Pair.
     *
     * @see agg.util.Pair The first element is a type, the second element is a name of a variable declaration, both
     * elements are of the type String.
     */
    public List<Pair<String, String>> getVariableDeclarations() {
        final List<Pair<String, String>> varDecls = new ArrayList<>(2);

        // search left graph
        putVarDecl(this.itsOrig.getNodesSet().iterator(), varDecls);
        putVarDecl(this.itsOrig.getArcsSet().iterator(), varDecls);

        // search right graph
        // first search values as a variable
        putVarDecl(this.itsImag.getNodesSet().iterator(), varDecls);
        putVarDecl(this.itsImag.getArcsSet().iterator(), varDecls);
        // now search values as a complex expression
        putVarOfExpr(this.itsImag.getNodesSet().iterator(), varDecls);
        putVarOfExpr(this.itsImag.getArcsSet().iterator(), varDecls);

        return varDecls;
    }

    private void putVarDecl(
            final Iterator<?> elems,
            final List<Pair<String, String>> varDecls) {
        while (elems.hasNext()) {
            GraphObject o = (GraphObject) elems.next();
            if (o.getAttribute() == null) {
                continue;
            }
            AttrInstance attr = o.getAttribute();
            ValueTuple vt = (ValueTuple) attr;
            for (int k = 0; k < vt.getSize(); k++) {
                ValueMember vm = vt.getValueMemberAt(k);
                if (vm.isSet() && vm.getExpr().isVariable()) {
                    String n = vm.getExprAsText();
                    String t = vm.getDeclaration().getTypeName();
//					System.out.println(o.getContext().getName()+"   "+n+"    "+t);
                    Pair<String, String> p = new Pair<String, String>(t, n);
                    boolean found = false;
                    for (int j = 0; j < varDecls.size(); j++) {
                        Pair<String, String> pj = varDecls.get(j);
                        if (t.equals(pj.first) && n.equals(pj.second)) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        varDecls.add(p);
                    }
                }
//				else if (vm.isSet() && !vm.getExpr().isVariable()) {
//					String n = vm.getExprAsText();
//					String t = vm.getDeclaration().getTypeName();
//
//					System.out.println(o.getContext().getName()+"   "+n+"   ###   "+t);
//				}
            }
        }
    }

    private void putVarOfExpr(
            final Iterator<?> elems,
            final List<Pair<String, String>> varDecls) {
        while (elems.hasNext()) {
            GraphObject o = (GraphObject) elems.next();
            if (o.getAttribute() == null) {
                continue;
            }
            AttrInstance attr = o.getAttribute();
            ValueTuple vt = (ValueTuple) attr;
            for (int k = 0; k < vt.getSize(); k++) {
                ValueMember vm = vt.getValueMemberAt(k);
                if (vm.isSet() && vm.getExpr().isComplex()) {
                    List<String> vec = vm.getAllVariableNamesOfExpression();
                    // System.out.println("vec: "+vec);
                    if (vec.size() != 0) {
                        for (int l = 0; l < vec.size(); l++) {
                            Pair<String, String> p = null;
                            String n = vec.get(l);
                            String t = "";
                            VarMember var = getAttrContext().getVariables()
                                    .getVarMemberAt(n);
                            if ((var != null) && (var.getDeclaration() != null)) {
                                t = var.getDeclaration().getTypeName();
                                p = new Pair<String, String>(t, n);
                                // System.out.println("decl pair: "+p);
                            } else {
                                String className = isClassName(n);
                                if (className != null) {
                                    t = className;
                                    p = new Pair<String, String>(t, n);
                                    // System.out.println("class pair: "+p);
                                } else {
                                    p = new Pair<String, String>(t, n);
                                }
                            }

                            boolean found = false;
                            for (int j = 0; j < varDecls.size(); j++) {
                                Pair<String, String> pj = varDecls
                                        .get(j);
                                if (t.equals(pj.first)
                                        && n.equals(pj.second)) {
                                    found = true;
                                }
                            }
                            if (!found) {
                                varDecls.add(p);
                            }
                        }
                    }
                }
            }
        }
    }

    public String isClassName(String name) {
        return AttrTupleManager.getDefaultManager().isClassName(name);
    }

    public List<Type> getUsedTypes() {
        final List<Type> vec = new ArrayList<>();

        addUsedType(this.itsOrig.getNodesSet().iterator(), vec);
        addUsedType(this.itsOrig.getArcsSet().iterator(), vec);

        addUsedType(this.itsImag.getNodesSet().iterator(), vec);
        addUsedType(this.itsImag.getArcsSet().iterator(), vec);

        return vec;
    }

    private void addUsedType(final Iterator<?> elems, final List<Type> vec) {
        while (elems.hasNext()) {
            GraphObject o = (GraphObject) elems.next();
            if (!vec.contains(o.getType())) {
                vec.add(o.getType());
            }
        }
    }

    protected final void propagateChange(agg.util.Change ch) {
        setChanged();
        notifyObservers(ch);
    }

    /**
     * Disables attribute conditions in which a variable inside is not declared.
     */
    public void disableUnusedAttrCondition() {
        final VarTuple avt = (VarTuple) this.getAttrContext().getVariables();
        final CondTuple act = (CondTuple) this.getAttrContext().getConditions();

        for (int k = 0; k < act.getSize(); k++) {
            final CondMember cm = act.getCondMemberAt(k);
            final List<String> vars = cm.getAllVariables();
            if (!vars.isEmpty()) {
                for (int i = 0; i < vars.size(); i++) {
                    final VarMember var = avt.getVarMemberAt(vars.get(i));
                    if (var == null) {
                        cm.setEnabled(false);
                        break;
                    }
                }
            }
        }
    }

    public void enableUnusedAttrCondition() {
        final VarTuple avt = (VarTuple) this.getAttrContext().getVariables();
        final CondTuple act = (CondTuple) this.getAttrContext().getConditions();

        for (int k = 0; k < act.getSize(); k++) {
            final CondMember cm = act.getCondMemberAt(k);
            final List<String> vars = cm.getAllVariables();
            if (!vars.isEmpty()) {
                for (int i = 0; i < vars.size(); i++) {
                    final VarMember var = avt.getVarMemberAt(vars.get(i));
                    if (var == null) {
                        cm.setEnabled(true);
                        break;
                    }
                }
            }
        }
    }

    public void removeUnusedVariableOfAttrContext() {
        VarTuple vars = (VarTuple) this.getAttrContext().getVariables();
        for (int i = 0; i < vars.getNumberOfEntries(); i++) {
            VarMember vm = vars.getVarMemberAt(i);
            String var = vm.getName();
            if (!this.getSource().getVariableNamesOfAttributes().contains(var)) {
                if (!this.getTarget().getVariableNamesOfAttributes().contains(var)) {
                    vars.getTupleType().deleteMemberAt(var);
//					System.out.println("Rule.removeVariableOfAttrContext::  removed: "+var);
                }
            }
        }
    }

    protected boolean tryToApplyAttrExpr(final Hashtable<String, String> valMembeHashcode2Expr) {
        return tryComputeAttrExpr(this.getSource().getNodesSet().iterator(),
                valMembeHashcode2Expr)
                && tryComputeAttrExpr(this.getSource().getArcsSet().iterator(),
                        valMembeHashcode2Expr);
    }

    private boolean tryComputeAttrExpr(
            final Iterator<?> elems,
            final Hashtable<String, String> valMemberHashcode2Expr) {
//		((VarTuple)ac.getVariables()).showVariables();

//		final VarTuple vars = ((VarTuple)this.getAttrContext().getVariables());
//		final CondTuple conds = (CondTuple)this.getAttrContext().getConditions();
        while (elems.hasNext()) {
            final GraphObject go = (GraphObject) elems.next();
            if (go.getAttribute() != null) {
                final ValueTuple val = (ValueTuple) go.getAttribute();
                for (int i = 0; i < val.getNumberOfEntries(); i++) {
                    ValueMember mem = val.getValueMemberAt(i);
                    if (mem.isSet() && mem.getExpr().isComplex()) {
                        boolean applied = false;
                        String expr = mem.getExprAsText();
                        valMemberHashcode2Expr.put(String.valueOf(mem.hashCode()), expr);
                        try {
//							System.out.println("tryComputeAttrExprOfNode:::  "+expr);
                            mem.getExpr().evaluate(this.getAttrContext());
                            applied = true;
                        } catch (AttrHandlerException ex) {
                        }
                        if (!applied) {
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    }

    protected void resetAttrValueAsExpr(final Hashtable<String, String> valMembeHashcoder2Expr) {
        resetAttrValueAsExpr(this.getSource().getNodesSet().iterator(), valMembeHashcoder2Expr);
        resetAttrValueAsExpr(this.getSource().getArcsSet().iterator(), valMembeHashcoder2Expr);
    }

    private void resetAttrValueAsExpr(final Iterator<?> elems,
            final Hashtable<String, String> valMembeHashcoder2Expr) {

        final VarTuple vars = ((VarTuple) this.getAttrContext().getVariables());
        final CondTuple conds = (CondTuple) this.getAttrContext().getConditions();

        while (elems.hasNext()) {
            final GraphObject go = (GraphObject) elems.next();
            if (go.getAttribute() != null) {
                final ValueTuple val = (ValueTuple) go.getAttribute();
                for (int i = 0; i < val.getNumberOfEntries(); i++) {
                    ValueMember mem = val.getValueMemberAt(i);
                    String expr = valMembeHashcoder2Expr.get(String.valueOf(mem.hashCode()));
                    if (expr != null) {
//						System.out.println(mem.getExprAsText());
                        mem.setExprAsText(expr);
//						System.out.println(mem.getExprAsText());
                        for (int j = 0; j < conds.getSize(); j++) {
                            CondMember cond = (CondMember) conds.getMemberAt(j);
                            if (cond.getExprAsText().endsWith("=".concat(expr))
                                    && cond.isTransient()
                                    && (cond.getMark() == CondMember.NAC || cond.getMark() == CondMember.PAC)) {
                                String nameStr = cond.getName();
                                conds.getTupleType().deleteMemberAt(j);
                                vars.getTupleType().deleteMemberAt(nameStr);
                            }
                        }
                    }
                }
            }
        }

//		vars.showVariables();
//		conds.showConditions();
    }

}
